<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Willie Lin"><link rel="alternative" href="/atom.xml" title="Willie Lin" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>腾讯Go安全指南 - Willie Lin</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">Willie Lin</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2021-11-04T01:21:49.000Z">2021 - 11 - 04 09:21:49</time><h1 class="post__title"><a href="/2021/11/04/腾讯Go安全指南/">腾讯Go安全指南</a></h1><div class="post__main echo"><!-- markdown="1" is required for GitHub Pages to render the TOC properly. -->
<details markdown="1"><br>  <summary>目录</summary><br><br>-   <a href="#1">1 通用类</a><br>    <em>   <a href="#1.1">I. 代码实现</a><br>        +   <a href="#1.1.1">1.1 内存管理</a><br>        +   <a href="#1.1.2">1.2 文件操作</a><br>        +   <a href="#1.1.3">1.3 系统接口</a><br>        +   <a href="#1.1.4">1.4 通信安全</a><br>        +   <a href="#1.1.5">1.5 敏感数据保护</a><br>        +   <a href="#1.1.6">1.6 加密解密</a><br>        +   <a href="#1.1.7">1.7 正则表达式</a><br><br>-   <a href="#2">2 后台类</a>
    </em>   <a href="#2.1">I. 代码实现</a><br>        +   <a href="#2.1.1">1.1 输入校验</a><br>        +   <a href="#2.1.2">1.2 SQL操作</a><br>        +   <a href="#2.1.3">1.3 网络请求</a><br>        +   <a href="#2.1.4">1.4 服务器端渲染</a><br>        +   <a href="#2.1.5">1.5 Web跨域</a><br>        +   <a href="#2.1.6">1.6 响应输出</a><br>        +   <a href="#2.1.7">1.7 会话管理</a><br>        +   <a href="#2.1.8">1.8 访问控制</a><br>        +   <a href="#2.1.9">1.9 并发保护</a><br></details>

<p><a id="1"></a></p>
<h1 id="通用类"><a href="#通用类" class="headerlink" title="通用类"></a>通用类</h1><p><a id="1.1"></a></p>
<h2 id="1-代码实现类"><a href="#1-代码实现类" class="headerlink" title="1. 代码实现类"></a>1. 代码实现类</h2><p><a id="1.1.1"></a></p>
<h3 id="1-1-内存管理"><a href="#1-1-内存管理" class="headerlink" title="1.1 内存管理"></a>1.1 内存管理</h3><h4 id="1-1-1【必须】切片长度校验"><a href="#1-1-1【必须】切片长度校验" class="headerlink" title="1.1.1【必须】切片长度校验"></a>1.1.1【必须】切片长度校验</h4><ul>
<li>在对slice进行操作时，必须判断长度是否合法，防止程序panic</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 未判断data的长度，可导致 index out of range</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">'U'</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">'Z'</span> &amp;&amp; data[<span class="number">3</span>] == <span class="string">'Z'</span> &amp;&amp; data[<span class="number">4</span>] == <span class="string">'E'</span> &amp;&amp; data[<span class="number">5</span>] == <span class="string">'R'</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Bad"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad: slice bounds out of range</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slice = []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	fmt.Println(slice[:<span class="number">10</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good: 使用data前应判断长度是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">6</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">'U'</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">'Z'</span> &amp;&amp; data[<span class="number">3</span>] == <span class="string">'Z'</span> &amp;&amp; data[<span class="number">4</span>] == <span class="string">'E'</span> &amp;&amp; data[<span class="number">5</span>] == <span class="string">'R'</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Good"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-2【必须】nil指针判断"><a href="#1-1-2【必须】nil指针判断" class="headerlink" title="1.1.2【必须】nil指针判断"></a>1.1.2【必须】nil指针判断</h4><ul>
<li>进行指针操作时，必须判断该指针是否为nil，防止程序panic，尤其在进行结构体Unmarshal时</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Packet <span class="keyword">struct</span> &#123;</span><br><span class="line">	PackeyType    <span class="keyword">uint8</span></span><br><span class="line">	PackeyVersion <span class="keyword">uint8</span></span><br><span class="line">	Data          *Data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">	Stat <span class="keyword">uint8</span></span><br><span class="line">	Len  <span class="keyword">uint8</span></span><br><span class="line">	Buf  [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Packet)</span> <span class="title">UnmarshalBinary</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(b) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> io.EOF</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.PackeyType = b[<span class="number">0</span>]</span><br><span class="line">	p.PackeyVersion = b[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若长度等于2，那么不会new Data</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(b) &gt; <span class="number">2</span> &#123;</span><br><span class="line">		p.Data = <span class="built_in">new</span>(Data)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad: 未判断指针是否为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	packet := <span class="built_in">new</span>(Packet)</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> err := packet.UnmarshalBinary(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Failed to unmarshal packet"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Stat: %v\n"</span>, packet.Data.Stat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good: 判断Data指针是否为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	packet := <span class="built_in">new</span>(Packet)</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := packet.UnmarshalBinary(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Failed to unmarshal packet"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> packet.Data == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Stat: %v\n"</span>, packet.Data.Stat)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-3【必须】整数安全"><a href="#1-1-3【必须】整数安全" class="headerlink" title="1.1.3【必须】整数安全"></a>1.1.3【必须】整数安全</h4><ul>
<li><p>在进行数字运算操作时，需要做好长度限制，防止外部输入运算导致异常：</p>
<ul>
<li>确保无符号整数运算时不会反转</li>
<li>确保有符号整数运算时不会出现溢出</li>
<li>确保整型转换时不会出现截断错误</li>
<li>确保整型转换时不会出现符号错误</li>
</ul>
</li>
<li><p>以下场景必须严格进行长度限制：</p>
<ul>
<li>作为数组索引</li>
<li>作为对象的长度或者大小</li>
<li>作为数组的边界（如作为循环计数器）</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 未限制长度，导致整数溢出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overflow</span><span class="params">(numControlByUser <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numInt <span class="keyword">int32</span> = <span class="number">0</span></span><br><span class="line">	numInt = numControlByUser + <span class="number">1</span></span><br><span class="line">	<span class="comment">// 对长度限制不当，导致整数溢出</span></span><br><span class="line">	fmt.Printf(<span class="string">"%d\n"</span>, numInt)</span><br><span class="line">	<span class="comment">// 使用numInt，可能导致其他错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	overflow(<span class="number">2147483647</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overflow</span><span class="params">(numControlByUser <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numInt <span class="keyword">int32</span> = <span class="number">0</span></span><br><span class="line">	numInt = numControlByUser + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> numInt &lt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"integer overflow"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"integer ok"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	overflow(<span class="number">2147483647</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-4【必须】make分配长度验证"><a href="#1-1-4【必须】make分配长度验证" class="headerlink" title="1.1.4【必须】make分配长度验证"></a>1.1.4【必须】make分配长度验证</h4><ul>
<li>在进行make分配内存时，需要对外部可控的长度进行校验，防止程序panic。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(lenControlByUser <span class="keyword">int</span>, data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	size := lenControlByUser</span><br><span class="line">	<span class="comment">// 对外部传入的size，进行长度判断以免导致panic</span></span><br><span class="line">	buffer := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">	<span class="built_in">copy</span>(buffer, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(lenControlByUser <span class="keyword">int</span>, data []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	size := lenControlByUser</span><br><span class="line">	<span class="comment">// 限制外部可控的长度大小范围</span></span><br><span class="line">	<span class="keyword">if</span> size &gt; <span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"value too large"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	buffer := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">	<span class="built_in">copy</span>(buffer, data)</span><br><span class="line">	<span class="keyword">return</span> buffer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-5【必须】禁止SetFinalizer和指针循环引用同时使用"><a href="#1-1-5【必须】禁止SetFinalizer和指针循环引用同时使用" class="headerlink" title="1.1.5【必须】禁止SetFinalizer和指针循环引用同时使用"></a>1.1.5【必须】禁止SetFinalizer和指针循环引用同时使用</h4><ul>
<li>当一个对象从被GC选中到移除内存之前，runtime.SetFinalizer()都不会执行，即使程序正常结束或者发生错误。由指针构成的“循环引用”虽然能被GC正确处理，但由于无法确定Finalizer依赖顺序，从而无法调用runtime.SetFinalizer()，导致目标对象无法变成可达状态，从而造成内存无法被回收。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b Data</span><br><span class="line">	a.o = &amp;b</span><br><span class="line">	b.o = &amp;a</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针循环引用，SetFinalizer()无法正常调用</span></span><br><span class="line">	runtime.SetFinalizer(&amp;a, <span class="function"><span class="keyword">func</span><span class="params">(d *Data)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"a %p final.\n"</span>, d)</span><br><span class="line">	&#125;)</span><br><span class="line">	runtime.SetFinalizer(&amp;b, <span class="function"><span class="keyword">func</span><span class="params">(d *Data)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"b %p final.\n"</span>, d)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		foo()</span><br><span class="line">		time.Sleep(time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-6【必须】禁止重复释放channel"><a href="#1-1-6【必须】禁止重复释放channel" class="headerlink" title="1.1.6【必须】禁止重复释放channel"></a>1.1.6【必须】禁止重复释放channel</h4><ul>
<li>重复释放一般存在于异常流程判断中，如果恶意攻击者构造出异常条件使程序重复释放channel，则会触发运行时panic，从而造成DoS攻击。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">	err := processBusiness()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c &lt;- <span class="number">0</span></span><br><span class="line">		<span class="built_in">close</span>(c) <span class="comment">// 重复释放channel</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(c) <span class="comment">// 使用defer延迟关闭channel</span></span><br><span class="line">	err := processBusiness()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c &lt;- <span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-7【必须】确保每个协程都能退出"><a href="#1-1-7【必须】确保每个协程都能退出" class="headerlink" title="1.1.7【必须】确保每个协程都能退出"></a>1.1.7【必须】确保每个协程都能退出</h4><ul>
<li>启动一个协程就会做一个入栈操作，在系统不退出的情况下，协程也没有设置退出条件，则相当于协程失去了控制，它占用的资源无法回收，可能会导致内存泄露。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 协程没有设置退出条件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWaiter</span><span class="params">(name <span class="keyword">string</span>, second <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(second) * time.Second)</span><br><span class="line">		fmt.Println(name, <span class="string">" is ready!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-8【推荐】不使用unsafe包"><a href="#1-1-8【推荐】不使用unsafe包" class="headerlink" title="1.1.8【推荐】不使用unsafe包"></a>1.1.8【推荐】不使用unsafe包</h4><ul>
<li>由于unsafe包绕过了 Golang 的内存安全原则，一般来说使用该库是不安全的，可导致内存破坏，尽量避免使用该包。若必须要使用unsafe操作指针，必须做好安全校验。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 通过unsafe操作原始指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafePointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>)</span><br><span class="line">	foo := (*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) + <span class="keyword">uintptr</span>(<span class="number">0xfffffff</span>e)))</span><br><span class="line">	fmt.Print(*foo + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [signal SIGSEGV: segmentation violation code=0x1 addr=0xc100068f55 pc=0x49142b]</span></span><br></pre></td></tr></table></figure>
<h4 id="1-1-9【推荐】不使用slice作为函数入参"><a href="#1-1-9【推荐】不使用slice作为函数入参" class="headerlink" title="1.1.9【推荐】不使用slice作为函数入参"></a>1.1.9【推荐】不使用slice作为函数入参</h4><ul>
<li>slice在作为函数入参时，函数内对slice的修改可能会影响原始数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="comment">// slice作为函数入参时包含原始数组指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(array []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// 对入参slice的元素修改会影响原始数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    modify(array)</span><br><span class="line">    fmt.Println(array) <span class="comment">// output：[10 2 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="comment">// 数组作为函数入参，而不是slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(array [5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 传入数组，注意数组与slice的区别</span></span><br><span class="line">    array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    modify(array)</span><br><span class="line">    fmt.Println(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="1.1.2"></a></p>
<h3 id="1-2-文件操作"><a href="#1-2-文件操作" class="headerlink" title="1.2 文件操作"></a>1.2 文件操作</h3><h4 id="1-2-1【必须】-路径穿越检查"><a href="#1-2-1【必须】-路径穿越检查" class="headerlink" title="1.2.1【必须】 路径穿越检查"></a>1.2.1【必须】 路径穿越检查</h4><ul>
<li>在进行文件操作时，如果对外部传入的文件名未做限制，可能导致任意文件读取或者任意文件写入，严重可能导致代码执行。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 任意文件读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	path := r.URL.Query()[<span class="string">"path"</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未过滤文件路径，可能导致任意文件读取</span></span><br><span class="line">	data, _ := ioutil.ReadFile(path)</span><br><span class="line">	w.Write(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对外部传入的文件名变量，还需要验证是否存在../等路径穿越的文件名</span></span><br><span class="line">	data, _ = ioutil.ReadFile(filepath.Join(<span class="string">"/home/user/"</span>, path))</span><br><span class="line">	w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad: 任意文件写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unzip</span><span class="params">(f <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	r, _ := zip.OpenReader(f)</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line">		p, _ := filepath.Abs(f.Name)</span><br><span class="line">		<span class="comment">// 未验证压缩文件名，可能导致../等路径穿越，任意文件路径写入</span></span><br><span class="line">		ioutil.WriteFile(p, []<span class="keyword">byte</span>(<span class="string">"present"</span>), <span class="number">0640</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good: 检查压缩的文件名是否包含..路径穿越特征字符，防止任意写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unzipGood</span><span class="params">(f <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	r, err := zip.OpenReader(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"read zip file fail"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line">		<span class="keyword">if</span> !strings.Contains(f.Name, <span class="string">".."</span>) &#123;</span><br><span class="line">			p, _ := filepath.Abs(f.Name)</span><br><span class="line">			ioutil.WriteFile(p, []<span class="keyword">byte</span>(<span class="string">"present"</span>), <span class="number">0640</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2【必须】-文件访问权限"><a href="#1-2-2【必须】-文件访问权限" class="headerlink" title="1.2.2【必须】 文件访问权限"></a>1.2.2【必须】 文件访问权限</h4><ul>
<li>根据创建文件的敏感性设置不同级别的访问权限，以防止敏感数据被任意权限用户读取。例如，设置文件权限为：<code>-rw-r-----</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioutil.WriteFile(p, []<span class="keyword">byte</span>(<span class="string">"present"</span>), <span class="number">0640</span>)</span><br></pre></td></tr></table></figure>
<p><a id="1.1.3"></a></p>
<h3 id="1-3-系统接口"><a href="#1-3-系统接口" class="headerlink" title="1.3 系统接口"></a>1.3 系统接口</h3><p><strong>1.3.1【必须】命令执行检查</strong></p>
<ul>
<li>使用<code>exec.Command</code>、<code>exec.CommandContext</code>、<code>syscall.StartProcess</code>、<code>os.StartProcess</code>等函数时，第一个参数（path）直接取外部输入值时，应使用白名单限定可执行的命令范围，不允许传入<code>bash</code>、<code>cmd</code>、<code>sh</code>等命令；</li>
<li>使用<code>exec.Command</code>、<code>exec.CommandContext</code>等函数时，通过<code>bash</code>、<code>cmd</code>、<code>sh</code>等创建shell，-c后的参数（arg）拼接外部输入，应过滤\n  $  &amp;  ;  |  ‘  “  ( )  `等潜在恶意字符；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	userInputedVal := <span class="string">"&amp;&amp; echo 'hello'"</span> <span class="comment">// 假设外部传入该变量值</span></span><br><span class="line">	cmdName := <span class="string">"ping "</span> + userInputedVal</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未判断外部输入是否存在命令注入字符，结合sh可造成命令注入</span></span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmdName)</span><br><span class="line">	output, _ := cmd.CombinedOutput()</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(output))</span><br><span class="line"></span><br><span class="line">	cmdName := <span class="string">"ls"</span></span><br><span class="line">	<span class="comment">// 未判断外部输入是否是预期命令</span></span><br><span class="line">	cmd := exec.Command(cmdName)</span><br><span class="line">	output, _ := cmd.CombinedOutput()</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(output))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkIllegal</span><span class="params">(cmdName <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> strings.Contains(cmdName, <span class="string">"&amp;"</span>) || strings.Contains(cmdName, <span class="string">"|"</span>) || strings.Contains(cmdName, <span class="string">";"</span>) ||</span><br><span class="line">		strings.Contains(cmdName, <span class="string">"$"</span>) || strings.Contains(cmdName, <span class="string">"'"</span>) || strings.Contains(cmdName, <span class="string">"`"</span>) ||</span><br><span class="line">		strings.Contains(cmdName, <span class="string">"("</span>) || strings.Contains(cmdName, <span class="string">")"</span>) || strings.Contains(cmdName, <span class="string">"\""</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	userInputedVal := <span class="string">"&amp;&amp; echo 'hello'"</span></span><br><span class="line">	cmdName := <span class="string">"ping "</span> + userInputedVal</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> checkIllegal(cmdName) &#123; <span class="comment">// 检查传给sh的命令是否有特殊字符</span></span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 存在特殊字符直接return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmdName)</span><br><span class="line">	output, _ := cmd.CombinedOutput()</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(output))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="1.1.4"></a></p>
<h3 id="1-4-通信安全"><a href="#1-4-通信安全" class="headerlink" title="1.4 通信安全"></a>1.4 通信安全</h3><h4 id="1-4-1【必须】网络通信采用TLS方式"><a href="#1-4-1【必须】网络通信采用TLS方式" class="headerlink" title="1.4.1【必须】网络通信采用TLS方式"></a>1.4.1【必须】网络通信采用TLS方式</h4><ul>
<li>明文传输的通信协议目前已被验证存在较大安全风险，被中间人劫持后可能导致许多安全风险，因此必须采用至少TLS的安全通信方式保证通信安全，例如gRPC/Websocket都使用TLS1.3。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		w.Header().Add(<span class="string">"Strict-Transport-Security"</span>, <span class="string">"max-age=63072000; includeSubDomains"</span>)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"This is an example server.\n"</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器配置证书与私钥</span></span><br><span class="line">	log.Fatal(http.ListenAndServeTLS(<span class="string">":443"</span>, <span class="string">"yourCert.pem"</span>, <span class="string">"yourKey.pem"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-2【推荐】TLS启用证书验证"><a href="#1-4-2【推荐】TLS启用证书验证" class="headerlink" title="1.4.2【推荐】TLS启用证书验证"></a>1.4.2【推荐】TLS启用证书验证</h4><ul>
<li>TLS证书应当是有效的、未过期的，且配置正确的域名，生产环境的服务端应启用证书验证。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto/tls"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doAuthReq</span><span class="params">(authReq *http.Request)</span> *<span class="title">http</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">	tr := &amp;http.Transport&#123;</span><br><span class="line">		TLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">true</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">	res, _ := client.Do(authReq)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto/tls"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doAuthReq</span><span class="params">(authReq *http.Request)</span> *<span class="title">http</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">	tr := &amp;http.Transport&#123;</span><br><span class="line">		TLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">false</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">	res, _ := client.Do(authReq)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="1.1.5"></a></p>
<h3 id="1-5-敏感数据保护"><a href="#1-5-敏感数据保护" class="headerlink" title="1.5 敏感数据保护"></a>1.5 敏感数据保护</h3><h4 id="1-5-1【必须】敏感信息访问"><a href="#1-5-1【必须】敏感信息访问" class="headerlink" title="1.5.1【必须】敏感信息访问"></a>1.5.1【必须】敏感信息访问</h4><ul>
<li>禁止将敏感信息硬编码在程序中，既可能会将敏感信息暴露给攻击者，也会增加代码管理和维护的难度</li>
<li>使用配置中心系统统一托管密钥等敏感信息</li>
</ul>
<h4 id="1-5-2【必须】敏感数据输出"><a href="#1-5-2【必须】敏感数据输出" class="headerlink" title="1.5.2【必须】敏感数据输出"></a>1.5.2【必须】敏感数据输出</h4><ul>
<li>只输出必要的最小数据集，避免多余字段暴露引起敏感信息泄露</li>
<li>不能在日志保存密码（包括明文密码和密文密码）、密钥和其它敏感信息</li>
<li>对于必须输出的敏感信息，必须进行合理脱敏展示</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/register"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		r.ParseForm()</span><br><span class="line">		user := r.Form.Get(<span class="string">"user"</span>)</span><br><span class="line">		pw := r.Form.Get(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">		log.Printf(<span class="string">"Registering new user %s with password %s.\n"</span>, user, pw)</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">":80"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/register"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		r.ParseForm()</span><br><span class="line">		user := r.Form.Get(<span class="string">"user"</span>)</span><br><span class="line">		pw := r.Form.Get(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">		log.Printf(<span class="string">"Registering new user %s.\n"</span>, user)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		use(pw)</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">":80"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免通过GET方法、代码注释、自动填充、缓存等方式泄露敏感信息</li>
</ul>
<h4 id="1-5-3【必须】敏感数据存储"><a href="#1-5-3【必须】敏感数据存储" class="headerlink" title="1.5.3【必须】敏感数据存储"></a>1.5.3【必须】敏感数据存储</h4><ul>
<li>敏感数据应使用SHA2、RSA等算法进行加密存储</li>
<li>敏感数据应使用独立的存储层，并在访问层开启访问控制</li>
<li>包含敏感信息的临时文件或缓存一旦不再需要应立刻删除</li>
</ul>
<h4 id="1-5-4【必须】异常处理和日志记录"><a href="#1-5-4【必须】异常处理和日志记录" class="headerlink" title="1.5.4【必须】异常处理和日志记录"></a>1.5.4【必须】异常处理和日志记录</h4><ul>
<li>应合理使用panic、recover、defer处理系统异常，避免出错信息输出到前端</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Recovered in start()"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<ul>
<li>对外环境禁止开启debug模式，或将程序运行日志输出到前端</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">dlv --listen=:2345 --headless=<span class="literal">true</span> --api-version=2 debug test.go</span><br><span class="line">// good</span><br><span class="line">dlv debug test.go</span><br></pre></td></tr></table></figure>
<p><a id="1.1.6"></a></p>
<h3 id="1-6-加密解密"><a href="#1-6-加密解密" class="headerlink" title="1.6 加密解密"></a>1.6 加密解密</h3><h4 id="1-6-1【必须】不得硬编码密码-密钥"><a href="#1-6-1【必须】不得硬编码密码-密钥" class="headerlink" title="1.6.1【必须】不得硬编码密码/密钥"></a>1.6.1【必须】不得硬编码密码/密钥</h4><ul>
<li>在进行用户登陆，加解密算法等操作时，不得在代码里硬编码密钥或密码，可通过变换算法或者配置等方式设置密码或者密钥。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	user     = <span class="string">"dbuser"</span></span><br><span class="line">	password = <span class="string">"s3cretp4ssword"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">()</span> *<span class="title">sql</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">	connStr := fmt.Sprintf(<span class="string">"postgres://%s:%s@localhost/pqgotest"</span>, user, password)</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, connStr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	commonkey = []<span class="keyword">byte</span>(<span class="string">"0123456789abcdef"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesEncrypt</span><span class="params">(plaintext <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	block, err := aes.NewCipher(commonkey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-2【必须】密钥存储安全"><a href="#1-6-2【必须】密钥存储安全" class="headerlink" title="1.6.2【必须】密钥存储安全"></a>1.6.2【必须】密钥存储安全</h4><ul>
<li>在使用对称密码算法时，需要保护好加密密钥。当算法涉及敏感、业务数据时，可通过非对称算法协商加密密钥。其他较为不敏感的数据加密，可以通过变换算法等方式保护密钥。</li>
</ul>
<h4 id="1-6-3【推荐】不使用弱密码算法"><a href="#1-6-3【推荐】不使用弱密码算法" class="headerlink" title="1.6.3【推荐】不使用弱密码算法"></a>1.6.3【推荐】不使用弱密码算法</h4><ul>
<li>在使用加密算法时，不建议使用加密强度较弱的算法。</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> bad</span><br><span class="line">crypto<span class="regexp">/des，crypto/m</span>d5，crypto<span class="regexp">/sha1，crypto/</span>rc4等。</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> good</span><br><span class="line">crypto<span class="regexp">/rsa，crypto/</span>aes等。</span><br></pre></td></tr></table></figure>
<p><a id="1.1.7"></a></p>
<h3 id="1-7-正则表达式"><a href="#1-7-正则表达式" class="headerlink" title="1.7 正则表达式"></a>1.7 正则表达式</h3><h4 id="1-7-1【推荐】使用regexp进行正则表达式匹配"><a href="#1-7-1【推荐】使用regexp进行正则表达式匹配" class="headerlink" title="1.7.1【推荐】使用regexp进行正则表达式匹配"></a>1.7.1【推荐】使用regexp进行正则表达式匹配</h4><ul>
<li>正则表达式编写不恰当可被用于DoS攻击，造成服务不可用，推荐使用regexp包进行正则表达式匹配。regexp保证了线性时间性能和优雅的失败：对解析器、编译器和执行引擎都进行了内存限制。但regexp不支持以下正则表达式特性，如业务依赖这些特性，则regexp不适合使用。<ul>
<li>回溯引用<a href="https://www.regular-expressions.info/backref.html" target="_blank" rel="noopener">Backreferences</a></li>
<li>查看<a href="https://www.regular-expressions.info/lookaround.html" target="_blank" rel="noopener">Lookaround</a></li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">matched, err := regexp.MatchString(<span class="string">`a.b`</span>, <span class="string">"aaxbb"</span>)</span><br><span class="line">fmt.Println(matched) <span class="comment">// true</span></span><br><span class="line">fmt.Println(err)     <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>
<p><a id="2"></a></p>
<h1 id="后台类"><a href="#后台类" class="headerlink" title="后台类"></a>后台类</h1><p><a id="2.1"></a></p>
<h2 id="1-代码实现类-1"><a href="#1-代码实现类-1" class="headerlink" title="1 代码实现类"></a>1 代码实现类</h2><p><a id="2.1.1"></a></p>
<h3 id="1-1-输入校验"><a href="#1-1-输入校验" class="headerlink" title="1.1 输入校验"></a>1.1 输入校验</h3><h4 id="1-1-1【必须】按类型进行数据校验"><a href="#1-1-1【必须】按类型进行数据校验" class="headerlink" title="1.1.1【必须】按类型进行数据校验"></a>1.1.1【必须】按类型进行数据校验</h4><ul>
<li>所有外部输入的参数，应使用<code>validator</code>进行白名单校验，校验内容包括但不限于数据长度、数据范围、数据类型与格式，校验不通过的应当拒绝</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/go-playground/validator/v10"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validate *validator.Validate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateVariable</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myEmail := <span class="string">"abc@tencent.com"</span></span><br><span class="line">	errs := validate.Var(myEmail, <span class="string">"required,email"</span>)</span><br><span class="line">	<span class="keyword">if</span> errs != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(errs)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">		<span class="comment">//停止执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 验证通过，继续执行</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	validate = validator.New()</span><br><span class="line">	validateVariable()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>无法通过白名单校验的应使用<code>html.EscapeString</code>、<code>text/template</code>或<code>bluemonday</code>对<code>&lt;, &gt;, &amp;, &#39;,&quot;</code>等字符进行过滤或编码</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"text/template"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestHTMLEscapeString HTML特殊字符转义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">(inputValue <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	escapedResult := template.HTMLEscapeString(inputValue)</span><br><span class="line">	<span class="keyword">return</span> escapedResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="2.1.2"></a></p>
<h3 id="1-2-SQL操作"><a href="#1-2-SQL操作" class="headerlink" title="1.2 SQL操作"></a>1.2 SQL操作</h3><h4 id="1-2-1【必须】SQL语句默认使用预编译并绑定变量"><a href="#1-2-1【必须】SQL语句默认使用预编译并绑定变量" class="headerlink" title="1.2.1【必须】SQL语句默认使用预编译并绑定变量"></a>1.2.1【必须】SQL语句默认使用预编译并绑定变量</h4><ul>
<li>使用<code>database/sql</code>的prepare、Query或使用GORM等ORM执行SQL操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/jinzhu/gorm"</span></span><br><span class="line">	_ <span class="string">"github.com/jinzhu/gorm/dialects/sqlite"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">	gorm.Model</span><br><span class="line">	Code  <span class="keyword">string</span></span><br><span class="line">	Price <span class="keyword">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> product Product</span><br><span class="line">...</span><br><span class="line">db.First(&amp;product, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用参数化查询，禁止拼接SQL语句，另外对于传入参数用于order by或表名的需要通过校验</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(db *sql.DB, req *http.Request)</span></span> &#123;</span><br><span class="line">	q := fmt.Sprintf(<span class="string">"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='%s' ORDER BY PRICE"</span>,</span><br><span class="line">		req.URL.Query()[<span class="string">"category"</span>])</span><br><span class="line">	db.Query(q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerGood</span><span class="params">(db *sql.DB, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用?占位符</span></span><br><span class="line">	q := <span class="string">"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='?' ORDER BY PRICE"</span></span><br><span class="line">	db.Query(q, req.URL.Query()[<span class="string">"category"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="2.1.3"></a></p>
<h3 id="1-3-网络请求"><a href="#1-3-网络请求" class="headerlink" title="1.3 网络请求"></a>1.3 网络请求</h3><h4 id="1-3-1【必须】资源请求过滤验证"><a href="#1-3-1【必须】资源请求过滤验证" class="headerlink" title="1.3.1【必须】资源请求过滤验证"></a>1.3.1【必须】资源请求过滤验证</h4><ul>
<li><p>使用<code>&quot;net/http&quot;</code>下的方法<code>http.Get(url)</code>、<code>http.Post(url, contentType, body)</code>、<code>http.Head(url)</code>、<code>http.PostForm(url, data)</code>、<code>http.Do(req)</code>时，如变量值外部可控（指从参数中动态获取），应对请求目标进行严格的安全校验。</p>
</li>
<li><p>如请求资源域名归属固定的范围，如只允许<code>a.qq.com</code>和<code>b.qq.com</code>，应做白名单限制。如不适用白名单，则推荐的校验逻辑步骤是：</p>
<ul>
<li><p>第 1 步、只允许HTTP或HTTPS协议</p>
</li>
<li><p>第 2 步、解析目标URL，获取其HOST</p>
</li>
<li><p>第 3 步、解析HOST，获取HOST指向的IP地址转换成Long型</p>
</li>
<li><p>第 4 步、检查IP地址是否为内网IP，网段有：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以RFC定义的专有网络为例，如有自定义私有网段亦应加入禁止访问列表。</span></span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">8</span></span><br><span class="line"><span class="number">172.16</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">12</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第 5 步、请求URL</p>
</li>
<li><p>第 6 步、如有跳转，跳转后执行1，否则绑定经校验的ip和域名，对URL发起请求</p>
</li>
</ul>
</li>
<li><p>官方库<code>encoding/xml</code>不支持外部实体引用，使用该库可避免xxe漏洞</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/xml"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">		XMLName  xml.Name <span class="string">`xml:"person"`</span></span><br><span class="line">		Id       <span class="keyword">int</span>      <span class="string">`xml:"id,attr"`</span></span><br><span class="line">		UserName <span class="keyword">string</span>   <span class="string">`xml:"name&gt;first"`</span></span><br><span class="line">		Comment  <span class="keyword">string</span>   <span class="string">`xml:",comment"`</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v := &amp;Person&#123;Id: <span class="number">13</span>, UserName: <span class="string">"John"</span>&#125;</span><br><span class="line">	v.Comment = <span class="string">" Need more details. "</span></span><br><span class="line"></span><br><span class="line">	enc := xml.NewEncoder(os.Stdout)</span><br><span class="line">	enc.Indent(<span class="string">"  "</span>, <span class="string">"    "</span>)</span><br><span class="line">	<span class="keyword">if</span> err := enc.Encode(v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="2.1.4"></a></p>
<h3 id="1-4-服务器端渲染"><a href="#1-4-服务器端渲染" class="headerlink" title="1.4 服务器端渲染"></a>1.4 服务器端渲染</h3><h4 id="1-4-1【必须】模板渲染过滤验证"><a href="#1-4-1【必须】模板渲染过滤验证" class="headerlink" title="1.4.1【必须】模板渲染过滤验证"></a>1.4.1【必须】模板渲染过滤验证</h4><ul>
<li>使用<code>text/template</code>或者<code>html/template</code>渲染模板时禁止将外部输入参数引入模板，或仅允许引入白名单内字符。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	r.ParseForm()</span><br><span class="line">	x := r.Form.Get(<span class="string">"name"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tmpl = <span class="string">`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;form action="/" method="post"&gt;</span></span><br><span class="line"><span class="string">        First name:&lt;br&gt;</span></span><br><span class="line"><span class="string">    &lt;input type="text" name="name" value=""&gt;</span></span><br><span class="line"><span class="string">    &lt;input type="submit" value="Submit"&gt;</span></span><br><span class="line"><span class="string">    &lt;/form&gt;&lt;p&gt;`</span> + x + <span class="string">` &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`</span></span><br><span class="line"></span><br><span class="line">	t := template.New(<span class="string">"main"</span>)</span><br><span class="line">	t, _ = t.Parse(tmpl)</span><br><span class="line">	t.Execute(w, <span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/go-playground/validator/v10"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validate *validator.Validate</span><br><span class="line">validate = validator.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateVariable</span><span class="params">(val)</span></span> &#123;</span><br><span class="line">	errs := validate.Var(val, <span class="string">"gte=1,lte=100"</span>) <span class="comment">// 限制必须是1-100的正整数</span></span><br><span class="line">	<span class="keyword">if</span> errs != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(errs)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	r.ParseForm()</span><br><span class="line">	x := r.Form.Get(<span class="string">"name"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> validateVariable(x) &#123;</span><br><span class="line">		<span class="keyword">var</span> tmpl = <span class="string">`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">            &lt;form action="/" method="post"&gt;</span></span><br><span class="line"><span class="string">            First name:&lt;br&gt;</span></span><br><span class="line"><span class="string">            &lt;input type="text" name="name" value=""&gt;</span></span><br><span class="line"><span class="string">            &lt;input type="submit" value="Submit"&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;&lt;p&gt;`</span> + x + <span class="string">` &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`</span></span><br><span class="line">		t := template.New(<span class="string">"main"</span>)</span><br><span class="line">		t, _ = t.Parse(tmpl)</span><br><span class="line">		t.Execute(w, <span class="string">"Hello"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="2.1.5"></a></p>
<h3 id="1-5-Web跨域"><a href="#1-5-Web跨域" class="headerlink" title="1.5 Web跨域"></a>1.5 Web跨域</h3><h4 id="1-5-1【必须】跨域资源共享CORS限制请求来源"><a href="#1-5-1【必须】跨域资源共享CORS限制请求来源" class="headerlink" title="1.5.1【必须】跨域资源共享CORS限制请求来源"></a>1.5.1【必须】跨域资源共享CORS限制请求来源</h4><ul>
<li>CORS请求保护不当可导致敏感信息泄漏，因此应当严格设置Access-Control-Allow-Origin使用同源策略进行保护。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">c := cors.New(cors.Options&#123;</span><br><span class="line">	AllowedOrigins:   []<span class="keyword">string</span>&#123;<span class="string">"http://qq.com"</span>, <span class="string">"https://qq.com"</span>&#125;,</span><br><span class="line">	AllowCredentials: <span class="literal">true</span>,</span><br><span class="line">	Debug:            <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入中间件</span></span><br><span class="line">handler = c.Handler(handler)</span><br></pre></td></tr></table></figure>
<p><a id="2.1.6"></a></p>
<h3 id="1-6-响应输出"><a href="#1-6-响应输出" class="headerlink" title="1.6 响应输出"></a>1.6 响应输出</h3><h4 id="1-6-1-【必须】设置正确的HTTP响应包类型"><a href="#1-6-1-【必须】设置正确的HTTP响应包类型" class="headerlink" title="1.6.1 【必须】设置正确的HTTP响应包类型"></a>1.6.1 【必须】设置正确的HTTP响应包类型</h4><ul>
<li>响应头Content-Type与实际响应内容，应保持一致。如：API响应数据类型是json，则响应头使用<code>application/json</code>；若为xml，则设置为<code>text/xml</code>。</li>
</ul>
<h4 id="1-6-2-【必须】添加安全响应头"><a href="#1-6-2-【必须】添加安全响应头" class="headerlink" title="1.6.2 【必须】添加安全响应头"></a>1.6.2 【必须】添加安全响应头</h4><ul>
<li>所有接口、页面，添加响应头 <code>X-Content-Type-Options: nosniff</code>。</li>
<li>所有接口、页面，添加响应头<code>X-Frame-Options</code>。按需合理设置其允许范围，包括：<code>DENY</code>、<code>SAMEORIGIN</code>、<code>ALLOW-FROM origin</code>。用法参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="noopener">MDN文档</a></li>
</ul>
<h4 id="1-6-3【必须】外部输入拼接到HTTP响应头中需进行过滤"><a href="#1-6-3【必须】外部输入拼接到HTTP响应头中需进行过滤" class="headerlink" title="1.6.3【必须】外部输入拼接到HTTP响应头中需进行过滤"></a>1.6.3【必须】外部输入拼接到HTTP响应头中需进行过滤</h4><ul>
<li>应尽量避免外部可控参数拼接到HTTP响应头中，如业务需要则需要过滤掉<code>\r</code>、<code>\n</code>等换行符，或者拒绝携带换行符号的外部输入。</li>
</ul>
<h4 id="1-6-4【必须】外部输入拼接到response页面前进行编码处理"><a href="#1-6-4【必须】外部输入拼接到response页面前进行编码处理" class="headerlink" title="1.6.4【必须】外部输入拼接到response页面前进行编码处理"></a>1.6.4【必须】外部输入拼接到response页面前进行编码处理</h4><ul>
<li>直出html页面或使用模板生成html页面的，推荐使用<code>text/template</code>自动编码，或者使用<code>html.EscapeString</code>或<code>text/template</code>对<code>&lt;, &gt;, &amp;, &#39;,&quot;</code>等字符进行编码。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"html/template"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outtemplate</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	param1 := r.URL.Query().Get(<span class="string">"param1"</span>)</span><br><span class="line">	tmpl := template.New(<span class="string">"hello"</span>)</span><br><span class="line">	tmpl, _ = tmpl.Parse(<span class="string">`&#123;&#123;define "T"&#125;&#125;&#123;&#123;.&#125;&#125;&#123;&#123;end&#125;&#125;`</span>)</span><br><span class="line">	tmpl.ExecuteTemplate(w, <span class="string">"T"</span>, param1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="2.1.7"></a></p>
<h3 id="1-7-会话管理"><a href="#1-7-会话管理" class="headerlink" title="1.7 会话管理"></a>1.7 会话管理</h3><h4 id="1-7-1【必须】安全维护session信息"><a href="#1-7-1【必须】安全维护session信息" class="headerlink" title="1.7.1【必须】安全维护session信息"></a>1.7.1【必须】安全维护session信息</h4><ul>
<li>用户登录时应重新生成session，退出登录后应清理session。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/gorilla/handlers"</span></span><br><span class="line">	<span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setToken</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	expireToken := time.Now().Add(time.Minute * <span class="number">30</span>).Unix()</span><br><span class="line">	expireCookie := time.Now().Add(time.Minute * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	cookie := http.Cookie&#123;</span><br><span class="line">		Name:     <span class="string">"Auth"</span>,</span><br><span class="line">		Value:    signedToken,</span><br><span class="line">		Expires:  expireCookie, <span class="comment">// 过期失效</span></span><br><span class="line">		HttpOnly: <span class="literal">true</span>,</span><br><span class="line">		Path:     <span class="string">"/"</span>,</span><br><span class="line">		Domain:   <span class="string">"127.0.0.1"</span>,</span><br><span class="line">		Secure:   <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.SetCookie(res, &amp;cookie)</span><br><span class="line">	http.Redirect(res, req, <span class="string">"/profile"</span>, <span class="number">307</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logout</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	deleteCookie := http.Cookie&#123;</span><br><span class="line">		Name:    <span class="string">"Auth"</span>,</span><br><span class="line">		Value:   <span class="string">"none"</span>,</span><br><span class="line">		Expires: time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">	http.SetCookie(res, &amp;deleteCookie)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-7-2【必须】CSRF防护"><a href="#1-7-2【必须】CSRF防护" class="headerlink" title="1.7.2【必须】CSRF防护"></a>1.7.2【必须】CSRF防护</h4><ul>
<li>涉及系统敏感操作或可读取敏感信息的接口应校验<code>Referer</code>或添加<code>csrf_token</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/gorilla/csrf"</span></span><br><span class="line">	<span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := mux.NewRouter()</span><br><span class="line">	r.HandleFunc(<span class="string">"/signup"</span>, ShowSignupForm)</span><br><span class="line">	r.HandleFunc(<span class="string">"/signup/post"</span>, SubmitSignupForm)</span><br><span class="line">	<span class="comment">// 使用csrf_token验证</span></span><br><span class="line">	http.ListenAndServe(<span class="string">":8000"</span>,</span><br><span class="line">		csrf.Protect([]<span class="keyword">byte</span>(<span class="string">"32-byte-long-auth-key"</span>))(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="2.1.8"></a></p>
<h3 id="1-8-访问控制"><a href="#1-8-访问控制" class="headerlink" title="1.8 访问控制"></a>1.8 访问控制</h3><h4 id="1-8-1【必须】默认鉴权"><a href="#1-8-1【必须】默认鉴权" class="headerlink" title="1.8.1【必须】默认鉴权"></a>1.8.1【必须】默认鉴权</h4><ul>
<li><p>除非资源完全可对外开放，否则系统默认进行身份认证，使用白名单的方式放开不需要认证的接口或页面。</p>
</li>
<li><p>根据资源的机密程度和用户角色，以最小权限原则，设置不同级别的权限，如完全公开、登录可读、登录可写、特定用户可读、特定用户可写等</p>
</li>
<li><p>涉及用户自身相关的数据的读写必须验证登录态用户身份及其权限，避免越权操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 伪代码</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span>=:<span class="keyword">id</span> <span class="keyword">and</span> userid=session.userid</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有独立账号体系的外网服务使用<code>QQ</code>或<code>微信</code>登录，内网服务使用<code>统一登录服务</code>登录，其他使用账号密码登录的服务需要增加验证码等二次验证</p>
</li>
</ul>
<p><a id="2.1.9"></a></p>
<h3 id="1-9-并发保护"><a href="#1-9-并发保护" class="headerlink" title="1.9 并发保护"></a>1.9 并发保护</h3><h4 id="1-9-1【必须】禁止在闭包中直接调用循环变量"><a href="#1-9-1【必须】禁止在闭包中直接调用循环变量" class="headerlink" title="1.9.1【必须】禁止在闭包中直接调用循环变量"></a>1.9.1【必须】禁止在闭包中直接调用循环变量</h4><ul>
<li>在循环中启动协程，当协程中使用到了循环的索引值，由于多个协程同时使用同一个变量会产生数据竞争，造成执行结果异常。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">	<span class="keyword">var</span> group sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		group.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> group.Done()</span><br><span class="line">			fmt.Printf(<span class="string">"%-2d"</span>, i) <span class="comment">// 这里打印的i不是所期望的</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	group.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">	<span class="keyword">var</span> group sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		group.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Println(<span class="string">"Recovered in start()"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				group.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">			fmt.Printf(<span class="string">"%-2d"</span>, j) <span class="comment">// 闭包内部使用局部变量</span></span><br><span class="line">		&#125;(i) <span class="comment">// 把循环变量显式地传给协程</span></span><br><span class="line">	&#125;</span><br><span class="line">	group.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-9-2【必须】禁止并发写map"><a href="#1-9-2【必须】禁止并发写map" class="headerlink" title="1.9.2【必须】禁止并发写map"></a>1.9.2【必须】禁止并发写map</h4><ul>
<li>并发写map容易造成程序崩溃并异常退出，建议加锁保护<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">// 并发读写</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			_ = m[<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			m[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-9-3【必须】确保并发安全"><a href="#1-9-3【必须】确保并发安全" class="headerlink" title="1.9.3【必须】确保并发安全"></a>1.9.3【必须】确保并发安全</h4><p>敏感操作如果未作并发安全限制，可导致数据读写异常，造成业务逻辑限制被绕过。可通过同步锁或者原子操作进行防护。</p>
<p>通过同步锁共享内存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(lock *sync.Mutex)</span></span> &#123;</span><br><span class="line">	lock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">	count++</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">	lock.Unlock() <span class="comment">// 解写锁，任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock := &amp;sync.Mutex&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Count(lock) <span class="comment">// 传递指针是为了防止函数内的锁和调用锁不一致</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		lock.Lock()</span><br><span class="line">		c := count</span><br><span class="line">		lock.Unlock()</span><br><span class="line">		runtime.Gosched() <span class="comment">// 交出时间片给协程</span></span><br><span class="line">		<span class="keyword">if</span> c &gt; <span class="number">10</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>sync/atomic</code>执行原子操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> m atomic.Value</span><br><span class="line">	m.Store(<span class="built_in">make</span>(Map))</span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex <span class="comment">// used only by writers</span></span><br><span class="line">	read := <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(val <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		m1 := m.Load().(Map)</span><br><span class="line">		<span class="keyword">return</span> m1[key]</span><br><span class="line">	&#125;</span><br><span class="line">	insert := <span class="function"><span class="keyword">func</span><span class="params">(key, val <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		mu.Lock() <span class="comment">// 与潜在写入同步</span></span><br><span class="line">		<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">		m1 := m.Load().(Map) <span class="comment">// 导入struct当前数据</span></span><br><span class="line">		m2 := <span class="built_in">make</span>(Map)      <span class="comment">// 创建新值</span></span><br><span class="line">		<span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">			m2[k] = v</span><br><span class="line">		&#125;</span><br><span class="line">		m2[key] = val</span><br><span class="line">		m.Store(m2) <span class="comment">// 用新的替代当前对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	_, _ = read, insert</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/腾讯，GO，Se/">腾讯，GO，Se</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat20.png" title="微信"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2016 - 2021 Willie Lin</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>