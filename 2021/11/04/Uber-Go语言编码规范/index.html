<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Willie Lin"><link rel="alternative" href="/atom.xml" title="Willie Lin" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Uber_Go语言编码规范 - Willie Lin</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">Willie Lin</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2021-11-04T01:15:16.000Z">2021 - 11 - 04 09:15:16</time><h1 class="post__title"><a href="/2021/11/04/Uber-Go语言编码规范/">Uber_Go语言编码规范</a></h1><div class="post__main echo"><!--

Editing this document:

- Discuss all changes in GitHub issues first.
- Update the table of contents as new sections are added or removed.
- Use tables for side-by-side code samples. See below.

Code Samples:

Use 2 spaces to indent. Horizontal real estate is important in side-by-side
samples.

For side-by-side code samples, use the following snippet.

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Bad<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Good<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">BAD CODE GOES HERE</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">GOOD CODE GOES HERE</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(You need the empty lines between the <td> and code samples for it to be<br>treated as Markdown.)</p>
<p>If you need to add labels or descriptions below the code samples, add another<br>row before the </tbody></table> line.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>DESCRIBE BAD CODE<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>DESCRIBE GOOD CODE<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h1 id="Uber-Go-Style-Guide"><a href="#Uber-Go-Style-Guide" class="headerlink" title="Uber Go Style Guide"></a>Uber Go Style Guide</h1><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#guidelines">Guidelines</a><ul>
<li><a href="#pointers-to-interfaces">Pointers to Interfaces</a></li>
<li><a href="#verify-interface-compliance">Verify Interface Compliance</a></li>
<li><a href="#receivers-and-interfaces">Receivers and Interfaces</a></li>
<li><a href="#zero-value-mutexes-are-valid">Zero-value Mutexes are Valid</a></li>
<li><a href="#copy-slices-and-maps-at-boundaries">Copy Slices and Maps at Boundaries</a></li>
<li><a href="#defer-to-clean-up">Defer to Clean Up</a></li>
<li><a href="#channel-size-is-one-or-none">Channel Size is One or None</a></li>
<li><a href="#start-enums-at-one">Start Enums at One</a></li>
<li><a href="#use-time-to-handle-time">Use <code>&quot;time&quot;</code> to handle time</a></li>
<li><a href="#error-types">Error Types</a></li>
<li><a href="#error-wrapping">Error Wrapping</a></li>
<li><a href="#handle-type-assertion-failures">Handle Type Assertion Failures</a></li>
<li><a href="#dont-panic">Don’t Panic</a></li>
<li><a href="#use-gouberorgatomic">Use go.uber.org/atomic</a></li>
<li><a href="#avoid-mutable-globals">Avoid Mutable Globals</a></li>
<li><a href="#avoid-embedding-types-in-public-structs">Avoid Embedding Types in Public Structs</a></li>
<li><a href="#avoid-using-built-in-names">Avoid Using Built-In Names</a></li>
<li><a href="#avoid-init">Avoid <code>init()</code></a></li>
<li><a href="#exit-in-main">Exit in Main</a><ul>
<li><a href="#exit-once">Exit Once</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#performance">Performance</a><ul>
<li><a href="#prefer-strconv-over-fmt">Prefer strconv over fmt</a></li>
<li><a href="#avoid-string-to-byte-conversion">Avoid string-to-byte conversion</a></li>
<li><a href="#prefer-specifying-container-capacity">Prefer Specifying Container Capacity</a><ul>
<li><a href="#specifying-map-capacity-hints">Specifying Map Capacity Hints</a></li>
<li><a href="#specifying-slice-capacity">Specifying Slice Capacity</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#style">Style</a><ul>
<li><a href="#be-consistent">Be Consistent</a></li>
<li><a href="#group-similar-declarations">Group Similar Declarations</a></li>
<li><a href="#import-group-ordering">Import Group Ordering</a></li>
<li><a href="#package-names">Package Names</a></li>
<li><a href="#function-names">Function Names</a></li>
<li><a href="#import-aliasing">Import Aliasing</a></li>
<li><a href="#function-grouping-and-ordering">Function Grouping and Ordering</a></li>
<li><a href="#reduce-nesting">Reduce Nesting</a></li>
<li><a href="#unnecessary-else">Unnecessary Else</a></li>
<li><a href="#top-level-variable-declarations">Top-level Variable Declarations</a></li>
<li><a href="#prefix-unexported-globals-with-_">Prefix Unexported Globals with _</a></li>
<li><a href="#embedding-in-structs">Embedding in Structs</a></li>
<li><a href="#local-variable-declarations">Local Variable Declarations</a></li>
<li><a href="#nil-is-a-valid-slice">nil is a valid slice</a></li>
<li><a href="#reduce-scope-of-variables">Reduce Scope of Variables</a></li>
<li><a href="#avoid-naked-parameters">Avoid Naked Parameters</a></li>
<li><a href="#use-raw-string-literals-to-avoid-escaping">Use Raw String Literals to Avoid Escaping</a></li>
<li><a href="#initializing-structs">Initializing Structs</a><ul>
<li><a href="#use-field-names-to-initialize-structs">Use Field Names to Initialize Structs</a></li>
<li><a href="#omit-zero-value-fields-in-structs">Omit Zero Value Fields in Structs</a></li>
<li><a href="#use-var-for-zero-value-structs">Use <code>var</code> for Zero Value Structs</a></li>
<li><a href="#initializing-struct-references">Initializing Struct References</a></li>
</ul>
</li>
<li><a href="#initializing-maps">Initializing Maps</a></li>
<li><a href="#format-strings-outside-printf">Format Strings outside Printf</a></li>
<li><a href="#naming-printf-style-functions">Naming Printf-style Functions</a></li>
</ul>
</li>
<li><a href="#patterns">Patterns</a><ul>
<li><a href="#test-tables">Test Tables</a></li>
<li><a href="#functional-options">Functional Options</a></li>
</ul>
</li>
<li><a href="#linting">Linting</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Styles are the conventions that govern our code. The term style is a bit of a<br>misnomer, since these conventions cover far more than just source file<br>formatting—gofmt handles that for us.</p>
<p>The goal of this guide is to manage this complexity by describing in detail the<br>Dos and Don’ts of writing Go code at Uber. These rules exist to keep the code<br>base manageable while still allowing engineers to use Go language features<br>productively.</p>
<p>This guide was originally created by <a href="https://github.com/prashantv">Prashant Varanasi</a> and <a href="https://github.com/nomis52">Simon Newton</a> as<br>a way to bring some colleagues up to speed with using Go. Over the years it has<br>been amended based on feedback from others.</p>
<p>This documents idiomatic conventions in Go code that we follow at Uber. A lot<br>of these are general guidelines for Go, while others extend upon external<br>resources:</p>
<ol>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
<li><a href="https://github.com/golang/go/wiki/CommonMistakes">Go Common Mistakes</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">Go Code Review Comments</a></li>
</ol>
<p>All code should be error-free when run through <code>golint</code> and <code>go vet</code>. We<br>recommend setting up your editor to:</p>
<ul>
<li>Run <code>goimports</code> on save</li>
<li>Run <code>golint</code> and <code>go vet</code> to check for errors</li>
</ul>
<p>You can find information in editor support for Go tools here:<br><a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></p>
<h2 id="Guidelines"><a href="#Guidelines" class="headerlink" title="Guidelines"></a>Guidelines</h2><h3 id="Pointers-to-Interfaces"><a href="#Pointers-to-Interfaces" class="headerlink" title="Pointers to Interfaces"></a>Pointers to Interfaces</h3><p>You almost never need a pointer to an interface. You should be passing<br>interfaces as values—the underlying data can still be a pointer.</p>
<p>An interface is two fields:</p>
<ol>
<li>A pointer to some type-specific information. You can think of this as<br>“type.”</li>
<li>Data pointer. If the data stored is a pointer, it’s stored directly. If<br>the data stored is a value, then a pointer to the value is stored.</li>
</ol>
<p>If you want interface methods to modify the underlying data, you must use a<br>pointer.</p>
<h3 id="Verify-Interface-Compliance"><a href="#Verify-Interface-Compliance" class="headerlink" title="Verify Interface Compliance"></a>Verify Interface Compliance</h3><p>Verify interface compliance at compile time where appropriate. This includes:</p>
<ul>
<li>Exported types that are required to implement specific interfaces as part of<br>their API contract</li>
<li>Exported or unexported types that are part of a collection of types<br>implementing the same interface</li>
<li>Other cases where violating an interface would break users</li>
</ul>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ http.Handler = (*Handler)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>The statement <code>var _ http.Handler = (*Handler)(nil)</code> will fail to compile if<br><code>*Handler</code> ever stops matching the <code>http.Handler</code> interface.</p>
<p>The right hand side of the assignment should be the zero value of the asserted<br>type. This is <code>nil</code> for pointer types (like <code>*Handler</code>), slices, and maps, and<br>an empty struct for struct types.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">  h   http.Handler</span><br><span class="line">  log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ http.Handler = LogHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h LogHandler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Receivers-and-Interfaces"><a href="#Receivers-and-Interfaces" class="headerlink" title="Receivers and Interfaces"></a>Receivers and Interfaces</h3><p>Methods with value receivers can be called on pointers as well as values.<br>Methods with pointer receivers can only be called on pointers or <a href="https://golang.org/ref/spec#Method_values">addressable values</a>.</p>
<p>For example,</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">Read</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span> <span class="title">Write</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  s.data = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sVals := <span class="keyword">map</span>[<span class="keyword">int</span>]S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can only call Read using a value</span></span><br><span class="line">sVals[<span class="number">1</span>].Read()</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will not compile:</span></span><br><span class="line"><span class="comment">//  sVals[1].Write("test")</span></span><br><span class="line"></span><br><span class="line">sPtrs := <span class="keyword">map</span>[<span class="keyword">int</span>]*S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can call both Read and Write using a pointer</span></span><br><span class="line">sPtrs[<span class="number">1</span>].Read()</span><br><span class="line">sPtrs[<span class="number">1</span>].Write(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure>
<p>Similarly, an interface can be satisfied by a pointer, even if the method has a<br>value receiver.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">s1Val := S1&#123;&#125;</span><br><span class="line">s1Ptr := &amp;S1&#123;&#125;</span><br><span class="line">s2Val := S2&#123;&#125;</span><br><span class="line">s2Ptr := &amp;S2&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i F</span><br><span class="line">i = s1Val</span><br><span class="line">i = s1Ptr</span><br><span class="line">i = s2Ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following doesn't compile, since s2Val is a value, and there is no value receiver for f.</span></span><br><span class="line"><span class="comment">//   i = s2Val</span></span><br></pre></td></tr></table></figure>
<p>Effective Go has a good write up on <a href="https://golang.org/doc/effective_go.html#pointers_vs_values">Pointers vs. Values</a>.</p>
<h3 id="Zero-value-Mutexes-are-Valid"><a href="#Zero-value-Mutexes-are-Valid" class="headerlink" title="Zero-value Mutexes are Valid"></a>Zero-value Mutexes are Valid</h3><p>The zero-value of <code>sync.Mutex</code> and <code>sync.RWMutex</code> is valid, so you almost<br>never need a pointer to a mutex.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>If you use a struct by pointer, then the mutex should be a non-pointer field on<br>it. Do not embed the mutex on the struct, even if the struct is not exported.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span> *<span class="title">SMap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span> *<span class="title">SMap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><br><tr><td><br><br>The <code>Mutex</code> field, and the <code>Lock</code> and <code>Unlock</code> methods are unintentionally part<br>of the exported API of <code>SMap</code>.<br><br></td><td><br><br>The mutex and its methods are implementation details of <code>SMap</code> hidden from its<br>callers.<br><br></td></tr><br></tbody></table>

<h3 id="Copy-Slices-and-Maps-at-Boundaries"><a href="#Copy-Slices-and-Maps-at-Boundaries" class="headerlink" title="Copy Slices and Maps at Boundaries"></a>Copy Slices and Maps at Boundaries</h3><p>Slices and maps contain pointers to the underlying data so be wary of scenarios<br>when they need to be copied.</p>
<h4 id="Receiving-Slices-and-Maps"><a href="#Receiving-Slices-and-Maps" class="headerlink" title="Receiving Slices and Maps"></a>Receiving Slices and Maps</h4><p>Keep in mind that users can modify a map or slice you received as an argument<br>if you store a reference to it.</p>
<table><br><thead><tr><th>Bad</th> <th>Good</th></tr></thead><br><tbody><br><tr><br><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Did you mean to modify d1.trips?</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure><br><br></td><br><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can now modify trips[0] without affecting d1.trips.</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure><br><br></td><br></tr><br><br></tbody><br></table>

<h4 id="Returning-Slices-and-Maps"><a href="#Returning-Slices-and-Maps" class="headerlink" title="Returning Slices and Maps"></a>Returning Slices and Maps</h4><p>Similarly, be wary of user modifications to maps or slices exposing internal<br>state.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot returns the current stats.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.counters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot is no longer protected by the mutex, so any</span></span><br><span class="line"><span class="comment">// access to the snapshot is subject to data races.</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s.counters))</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot is now a copy.</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Defer-to-Clean-Up"><a href="#Defer-to-Clean-Up" class="headerlink" title="Defer to Clean Up"></a>Defer to Clean Up</h3><p>Use defer to clean up resources such as files and locks.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  p.Unlock()</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line">newCount := p.count</span><br><span class="line">p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newCount</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy to miss unlocks due to multiple returns</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line"><span class="keyword">return</span> p.count</span><br><span class="line"></span><br><span class="line"><span class="comment">// more readable</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Defer has an extremely small overhead and should be avoided only if you can<br>prove that your function execution time is in the order of nanoseconds. The<br>readability win of using defers is worth the miniscule cost of using them. This<br>is especially true for larger methods that have more than simple memory<br>accesses, where the other computations are more significant than the <code>defer</code>.</p>
<h3 id="Channel-Size-is-One-or-None"><a href="#Channel-Size-is-One-or-None" class="headerlink" title="Channel Size is One or None"></a>Channel Size is One or None</h3><p>Channels should usually have a size of one or be unbuffered. By default,<br>channels are unbuffered and have a size of zero. Any other size<br>must be subject to a high level of scrutiny. Consider how the size is<br>determined, what prevents the channel from filling up under load and blocking<br>writers, and what happens when this occurs.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ought to be enough for anybody!</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Size of one</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// or</span></span><br><span class="line"><span class="comment">// Unbuffered channel, size of zero</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Start-Enums-at-One"><a href="#Start-Enums-at-One" class="headerlink" title="Start Enums at One"></a>Start Enums at One</h3><p>The standard way of introducing enumerations in Go is to declare a custom type<br>and a <code>const</code> group with <code>iota</code>. Since variables have a 0 default value, you<br>should usually start your enums on a non-zero value.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>There are cases where using the zero value makes sense, for example when the<br>zero value case is the desirable default behavior.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogOutput <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  LogToStdout LogOutput = <span class="literal">iota</span></span><br><span class="line">  LogToFile</span><br><span class="line">  LogToRemote</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogToStdout=0, LogToFile=1, LogToRemote=2</span></span><br></pre></td></tr></table></figure>
<h3 id="Use-quot-time-quot-to-handle-time"><a href="#Use-quot-time-quot-to-handle-time" class="headerlink" title="Use &quot;time&quot; to handle time"></a>Use <code>&quot;time&quot;</code> to handle time</h3><p>Time is complicated. Incorrect assumptions often made about time include the<br>following.</p>
<ol>
<li>A day has 24 hours</li>
<li>An hour has 60 minutes</li>
<li>A week has 7 days</li>
<li>A year has 365 days</li>
<li><a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">And a lot more</a></li>
</ol>
<p>For example, <em>1</em> means that adding 24 hours to a time instant will not always<br>yield a new calendar day.</p>
<p>Therefore, always use the <a href="https://golang.org/pkg/time/"><code>&quot;time&quot;</code></a> package when dealing with time because it<br>helps deal with these incorrect assumptions in a safer, more accurate manner.</p>
<h4 id="Use-time-Time-for-instants-of-time"><a href="#Use-time-Time-for-instants-of-time" class="headerlink" title="Use time.Time for instants of time"></a>Use <code>time.Time</code> for instants of time</h4><p>Use <a href="https://golang.org/pkg/time/#Time"><code>time.Time</code></a> when dealing with instants of time, and the methods on<br><code>time.Time</code> when comparing, adding, or subtracting time.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop time.Time)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h4 id="Use-time-Duration-for-periods-of-time"><a href="#Use-time-Duration-for-periods-of-time" class="headerlink" title="Use time.Duration for periods of time"></a>Use <code>time.Duration</code> for periods of time</h4><p>Use <a href="https://golang.org/pkg/time/#Duration"><code>time.Duration</code></a> when dealing with periods of time.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(time.Duration(delay) * time.Millisecond)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">poll(<span class="number">10</span>) <span class="comment">// was it seconds or milliseconds?</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">poll(<span class="number">10</span>*time.Second)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Going back to the example of adding 24 hours to a time instant, the method we<br>use to add time depends on intent. If we want the same time of the day, but on<br>the next calendar day, we should use <a href="https://golang.org/pkg/time/#Time.AddDate"><code>Time.AddDate</code></a>. However, if we want an<br>instant of time guaranteed to be 24 hours after the previous time, we should<br>use <a href="https://golang.org/pkg/time/#Time.Add"><code>Time.Add</code></a>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newDay := t.AddDate(<span class="number">0</span> <span class="comment">/* years */</span>, <span class="number">0</span> <span class="comment">/* months */</span>, <span class="number">1</span> <span class="comment">/* days */</span>)</span><br><span class="line">maybeNewDay := t.Add(<span class="number">24</span> * time.Hour)</span><br></pre></td></tr></table></figure>
<h4 id="Use-time-Time-and-time-Duration-with-external-systems"><a href="#Use-time-Time-and-time-Duration-with-external-systems" class="headerlink" title="Use time.Time and time.Duration with external systems"></a>Use <code>time.Time</code> and <code>time.Duration</code> with external systems</h4><p>Use <code>time.Duration</code> and <code>time.Time</code> in interactions with external systems when<br>possible. For example:</p>
<ul>
<li>Command-line flags: <a href="https://golang.org/pkg/flag/"><code>flag</code></a> supports <code>time.Duration</code> via<br><a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a></li>
<li>JSON: <a href="https://golang.org/pkg/encoding/json/"><code>encoding/json</code></a> supports encoding <code>time.Time</code> as an <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a><br>string via its <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON"><code>UnmarshalJSON</code> method</a></li>
<li>SQL: <a href="https://golang.org/pkg/database/sql/"><code>database/sql</code></a> supports converting <code>DATETIME</code> or <code>TIMESTAMP</code> columns<br>into <code>time.Time</code> and back if the underlying driver supports it</li>
<li>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2"><code>gopkg.in/yaml.v2</code></a> supports <code>time.Time</code> as an <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> string, and<br><code>time.Duration</code> via <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a>.</li>
</ul>
<p>When it is not possible to use <code>time.Duration</code> in these interactions, use<br><code>int</code> or <code>float64</code> and include the unit in the name of the field.</p>
<p>For example, since <code>encoding/json</code> does not support <code>time.Duration</code>, the unit<br>is included in the name of the field.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;"interval": 2&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Interval <span class="keyword">int</span> <span class="string">`json:"interval"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;"intervalMillis": 2000&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  IntervalMillis <span class="keyword">int</span> <span class="string">`json:"intervalMillis"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>When it is not possible to use <code>time.Time</code> in these interactions, unless an<br>alternative is agreed upon, use <code>string</code> and format timestamps as defined in<br><a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a>. This format is used by default by <a href="https://golang.org/pkg/time/#Time.UnmarshalText"><code>Time.UnmarshalText</code></a> and is<br>available for use in <code>Time.Format</code> and <code>time.Parse</code> via <a href="https://golang.org/pkg/time/#RFC3339"><code>time.RFC3339</code></a>.</p>
<p>Although this tends to not be a problem in practice, keep in mind that the<br><code>&quot;time&quot;</code> package does not support parsing timestamps with leap seconds<br>(<a href="https://github.com/golang/go/issues/8728">8728</a>), nor does it account for leap seconds in calculations (<a href="https://github.com/golang/go/issues/15190">15190</a>). If<br>you compare two instants of time, the difference will not include the leap<br>seconds that may have occurred between those two instants.</p>
<!-- TODO: section on String methods for enums -->
<h3 id="Error-Types"><a href="#Error-Types" class="headerlink" title="Error Types"></a>Error Types</h3><p>There are various options for declaring errors:</p>
<ul>
<li><a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> for errors with simple static strings</li>
<li><a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> for formatted error strings</li>
<li>Custom types that implement an <code>Error()</code> method</li>
<li>Wrapped errors using <a href="https://godoc.org/github.com/pkg/errors#Wrap" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Wrap</code></a></li>
</ul>
<p>When returning errors, consider the following to determine the best choice:</p>
<ul>
<li>Is this a simple error that needs no extra information? If so, <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a><br>should suffice.</li>
<li>Do the clients need to detect and handle this error? If so, you should use a<br>custom type, and implement the <code>Error()</code> method.</li>
<li>Are you propagating an error returned by a downstream function? If so, check<br>the <a href="#error-wrapping">section on error wrapping</a>.</li>
<li>Otherwise, <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> is okay.</li>
</ul>
<p>If the client needs to detect the error, and you have created a simple error<br>using <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a>, use a var for the error.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"could not open"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err.Error() == <span class="string">"could not open"</span> &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> errors.Is(err, foo.ErrCouldNotOpen) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>If you have an error that clients may need to detect, and you would like to add<br>more information to it (e.g., it is not a static string), then you should use a<br>custom type.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">"file %q not found"</span>, file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">"not found"</span>) &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(errNotFound); ok &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Be careful with exporting custom error types directly since they become part of<br>the public API of the package. It is preferable to expose matcher functions to<br>check the error instead.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  _, ok := err.(errNotFound)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">"foo"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> foo.IsNotFoundError(err) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- TODO: Exposing the information to callers with accessor functions. -->
<h3 id="Error-Wrapping"><a href="#Error-Wrapping" class="headerlink" title="Error Wrapping"></a>Error Wrapping</h3><p>There are three main options for propagating errors if a call fails:</p>
<ul>
<li>Return the original error if there is no additional context to add and you<br>want to maintain the original error type.</li>
<li>Add context using <a href="https://godoc.org/github.com/pkg/errors#Wrap" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Wrap</code></a> so that the error message provides<br>more context and <a href="https://godoc.org/github.com/pkg/errors#Cause" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Cause</code></a> can be used to extract the original<br>error.</li>
<li>Use <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> if the callers do not need to detect or handle that<br>specific error case.</li>
</ul>
<p>It is recommended to add context where possible so that instead of a vague<br>error such as “connection refused”, you get more useful errors such as<br>“call service foo: connection refused”.</p>
<p>When adding context to returned errors, keep the context succinct by avoiding<br>phrases like “failed to”, which state the obvious and pile up as the error<br>percolates up through the stack:</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"failed to create new store: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"new store: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><tr><td><br><br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed <span class="built_in">to</span> x: failed <span class="built_in">to</span> y: failed <span class="built_in">to</span> <span class="built_in">create</span> <span class="built_in">new</span> store: <span class="keyword">the</span> error</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">x:</span> <span class="string">y:</span> <span class="keyword">new</span> <span class="string">store:</span> the error</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>However once the error is sent to another system, it should be clear the<br>message is an error (e.g. an <code>err</code> tag or “Failed” prefix in logs).</p>
<p>See also <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Don’t just check errors, handle them gracefully</a>.</p>
<h3 id="Handle-Type-Assertion-Failures"><a href="#Handle-Type-Assertion-Failures" class="headerlink" title="Handle Type Assertion Failures"></a>Handle Type Assertion Failures</h3><p>The single return value form of a <a href="https://golang.org/ref/spec#Type_assertions" target="_blank" rel="noopener">type assertion</a> will panic on an incorrect<br>type. Therefore, always use the “comma ok” idiom.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// handle the error gracefully</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<!-- TODO: There are a few situations where the single assignment form is
fine. -->
<h3 id="Don’t-Panic"><a href="#Don’t-Panic" class="headerlink" title="Don’t Panic"></a>Don’t Panic</h3><p>Code running in production must avoid panics. Panics are a major source of<br><a href="https://en.wikipedia.org/wiki/Cascading_failure" target="_blank" rel="noopener">cascading failures</a>. If an error occurs, the function must return an error and<br>allow the caller to decide how to handle it.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"an argument is required"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  run(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"an argument is required"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(os.Args[<span class="number">1</span>:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Panic/recover is not an error handling strategy. A program must panic only when<br>something irrecoverable happens such as a nil dereference. An exception to this is<br>program initialization: bad things at program startup that should abort the<br>program may cause panic.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _statusTemplate = template.Must(template.New(<span class="string">"name"</span>).Parse(<span class="string">"_statusHTML"</span>))</span><br></pre></td></tr></table></figure>
<p>Even in tests, prefer <code>t.Fatal</code> or <code>t.FailNow</code> over panics to ensure that the<br>test is marked as failed.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatal(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<!-- TODO: Explain how to use _test packages. -->
<h3 id="Use-go-uber-org-atomic"><a href="#Use-go-uber-org-atomic" class="headerlink" title="Use go.uber.org/atomic"></a>Use go.uber.org/atomic</h3><p>Atomic operations with the <a href="https://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener">sync/atomic</a> package operate on the raw types<br>(<code>int32</code>, <code>int64</code>, etc.) so it is easy to forget to use the atomic operation to<br>read or modify the variables.</p>
<p><a href="https://godoc.org/go.uber.org/atomic" target="_blank" rel="noopener">go.uber.org/atomic</a> adds type safety to these operations by hiding the<br>underlying type. Additionally, it includes a convenient <code>atomic.Bool</code> type.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running <span class="keyword">int32</span>  <span class="comment">// atomic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f* foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.SwapInt32(&amp;f.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running == <span class="number">1</span>  <span class="comment">// race!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> f.running.Swap(<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Avoid-Mutable-Globals"><a href="#Avoid-Mutable-Globals" class="headerlink" title="Avoid Mutable Globals"></a>Avoid Mutable Globals</h3><p>Avoid mutating global variables, instead opting for dependency injection.<br>This applies to function pointers as well as other kinds of values.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _timeNow = time.Now</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  now := _timeNow()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;</span><br><span class="line">  now <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">newSigner</span><span class="params">()</span> *<span class="title">signer</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;signer&#123;</span><br><span class="line">    now: time.Now,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span> <span class="title">Sign</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  now := s.now()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSign</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  oldTimeNow := _timeNow</span><br><span class="line">  _timeNow = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _timeNow = oldTimeNow &#125;()</span><br><span class="line"></span><br><span class="line">  assert.Equal(t, want, sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSigner</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  s := newSigner()</span><br><span class="line">  s.now = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert.Equal(t, want, s.Sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Avoid-Embedding-Types-in-Public-Structs"><a href="#Avoid-Embedding-Types-in-Public-Structs" class="headerlink" title="Avoid Embedding Types in Public Structs"></a>Avoid Embedding Types in Public Structs</h3><p>These embedded types leak implementation details, inhibit type evolution, and<br>obscure documentation.</p>
<p>Assuming you have implemented a variety of list types using a shared<br><code>AbstractList</code>, avoid embedding the <code>AbstractList</code> in your concrete list<br>implementations.<br>Instead, hand-write only the methods to your concrete list that will delegate<br>to the abstract list.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds an entity to the list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove removes an entity from the list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList is a list of entities.</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  *AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList is a list of entities.</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list *AbstractList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds an entity to the list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove removes an entity from the list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Go allows <a href="https://golang.org/doc/effective_go.html#embedding" target="_blank" rel="noopener">type embedding</a> as a compromise between inheritance and composition.<br>The outer type gets implicit copies of the embedded type’s methods.<br>These methods, by default, delegate to the same method of the embedded<br>instance.</p>
<p>The struct also gains a field by the same name as the type.<br>So, if the embedded type is public, the field is public.<br>To maintain backward compatibility, every future version of the outer type must<br>keep the embedded type.</p>
<p>An embedded type is rarely necessary.<br>It is a convenience that helps you avoid writing tedious delegate methods.</p>
<p>Even embedding a compatible AbstractList <em>interface</em>, instead of the struct,<br>would offer the developer more flexibility to change in the future, but still<br>leak the detail that the concrete lists use an abstract implementation.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractList is a generalized implementation</span></span><br><span class="line"><span class="comment">// for various kinds of lists of entities.</span></span><br><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">interface</span> &#123;</span><br><span class="line">  Add(Entity)</span><br><span class="line">  Remove(Entity)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteList is a list of entities.</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList is a list of entities.</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list AbstractList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds an entity to the list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove removes an entity from the list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Either with an embedded struct or an embedded interface, the embedded type<br>places limits on the evolution of the type.</p>
<ul>
<li>Adding methods to an embedded interface is a breaking change.</li>
<li>Removing methods from an embedded struct is a breaking change.</li>
<li>Removing the embedded type is a breaking change.</li>
<li>Replacing the embedded type, even with an alternative that satisfies the same<br>interface, is a breaking change.</li>
</ul>
<p>Although writing these delegate methods is tedious, the additional effort hides<br>an implementation detail, leaves more opportunities for change, and also<br>eliminates indirection for discovering the full List interface in<br>documentation.</p>
<h3 id="Avoid-Using-Built-In-Names"><a href="#Avoid-Using-Built-In-Names" class="headerlink" title="Avoid Using Built-In Names"></a>Avoid Using Built-In Names</h3><p>The Go <a href="https://golang.org/ref/spec" target="_blank" rel="noopener">language specification</a> outlines several built-in,<br><a href="https://golang.org/ref/spec#Predeclared_identifiers" target="_blank" rel="noopener">predeclared identifiers</a> that should not be used as names within Go programs.</p>
<p>Depending on context, reusing these identifiers as names will either shadow<br>the original within the current lexical scope (and any nested scopes) or make<br>affected code confusing. In the best case, the compiler will complain; in the<br>worst case, such code may introduce latent, hard-to-grep bugs.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> error <span class="keyword">string</span></span><br><span class="line"><span class="comment">// `error` shadows the builtin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(error <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` shadows the builtin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage <span class="keyword">string</span></span><br><span class="line"><span class="comment">// `error` refers to the builtin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` refers to the builtin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// While these fields technically don't</span></span><br><span class="line">    <span class="comment">// constitute shadowing, grepping for</span></span><br><span class="line">    <span class="comment">// `error` or `string` strings is now</span></span><br><span class="line">    <span class="comment">// ambiguous.</span></span><br><span class="line">    error  error</span><br><span class="line">    <span class="keyword">string</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` and `f.error` are</span></span><br><span class="line">    <span class="comment">// visually similar</span></span><br><span class="line">    <span class="keyword">return</span> f.error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// `string` and `f.string` are</span></span><br><span class="line">    <span class="comment">// visually similar</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// `error` and `string` strings are</span></span><br><span class="line">    <span class="comment">// now unambiguous.</span></span><br><span class="line">    err error</span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>


<p>Note that the compiler will not generate errors when using predeclared<br>identifiers, but tools such as <code>go vet</code> should correctly point out these and<br>other cases of shadowing.</p>
<h3 id="Avoid-init"><a href="#Avoid-init" class="headerlink" title="Avoid init()"></a>Avoid <code>init()</code></h3><p>Avoid <code>init()</code> where possible. When <code>init()</code> is unavoidable or desirable, code<br>should attempt to:</p>
<ol>
<li>Be completely deterministic, regardless of program environment or invocation.</li>
<li>Avoid depending on the ordering or side-effects of other <code>init()</code> functions.<br>While <code>init()</code> ordering is well-known, code can change, and thus<br>relationships between <code>init()</code> functions can make code brittle and<br>error-prone.</li>
<li>Avoid accessing or manipulating global or environment state, such as machine<br>information, environment variables, working directory, program<br>arguments/inputs, etc.</li>
<li>Avoid I/O, including both filesystem, network, and system calls.</li>
</ol>
<p>Code that cannot satisfy these requirements likely belongs as a helper to be<br>called as part of <code>main()</code> (or elsewhere in a program’s lifecycle), or be<br>written as part of <code>main()</code> itself. In particular, libraries that are intended<br>to be used by other programs should take special care to be completely<br>deterministic and not perform “init magic”.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _defaultFoo Foo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _defaultFoo = Foo&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _defaultFoo = Foo&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or, better, for testability:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _defaultFoo = defaultFoo()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultFoo</span><span class="params">()</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Foo&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _config Config</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Bad: based on current directory</span></span><br><span class="line">    cwd, _ := os.Getwd()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bad: I/O</span></span><br><span class="line">    raw, _ := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">"config"</span>, <span class="string">"config.yaml"</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    yaml.Unmarshal(raw, &amp;_config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">    cwd, err := os.Getwd()</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line"></span><br><span class="line">    raw, err := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">"config"</span>, <span class="string">"config.yaml"</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> config Config</span><br><span class="line">    yaml.Unmarshal(raw, &amp;config)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Considering the above, some situations in which <code>init()</code> may be preferable or<br>necessary might include:</p>
<ul>
<li>Complex expressions that cannot be represented as single assignments.</li>
<li>Pluggable hooks, such as <code>database/sql</code> dialects, encoding type registries, etc.</li>
<li>Optimizations to <a href="https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations" target="_blank" rel="noopener">Google Cloud Functions</a> and other forms of deterministic<br>precomputation.</li>
</ul>
<h3 id="Exit-in-Main"><a href="#Exit-in-Main" class="headerlink" title="Exit in Main"></a>Exit in Main</h3><p>Go programs use <a href="https://golang.org/pkg/os/#Exit" target="_blank" rel="noopener"><code>os.Exit</code></a> or <a href="https://golang.org/pkg/log/#Fatal" target="_blank" rel="noopener"><code>log.Fatal*</code></a> to exit immediately. (Panicking<br>is not a good way to exit programs, please <a href="#dont-panic">don’t panic</a>.)</p>
<p>Call one of <code>os.Exit</code> or <code>log.Fatal*</code> <strong>only in <code>main()</code></strong>. All other<br>functions should return errors to signal failure.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  body := readFile(path)</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  body, err := readFile(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(b), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Rationale: Programs with multiple functions that exit present a few issues:</p>
<ul>
<li>Non-obvious control flow: Any function can exit the program so it becomes<br>difficult to reason about the control flow.</li>
<li>Difficult to test: A function that exits the program will also exit the test<br>calling it. This makes the function difficult to test and introduces risk of<br>skipping other tests that have not yet been run by <code>go test</code>.</li>
<li>Skipped cleanup: When a function exits the program, it skips function calls<br>enqueued with <code>defer</code> statements. This adds risk of skipping important<br>cleanup tasks.</li>
</ul>
<h4 id="Exit-Once"><a href="#Exit-Once" class="headerlink" title="Exit Once"></a>Exit Once</h4><p>If possible, prefer to call <code>os.Exit</code> or <code>log.Fatal</code> <strong>at most once</strong> in your<br><code>main()</code>. If there are multiple error scenarios that halt program execution,<br>put that logic under a separate function and return errors from it.</p>
<p>This has the effect of shortening your <code>main()</code> function and putting all key<br>business logic into a separate, testable function.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"missing file"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we call log.Fatal after this line,</span></span><br><span class="line">  <span class="comment">// f.Close will not be called.</span></span><br><span class="line"></span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"missing file"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>Performance-specific guidelines apply only to the hot path.</p>
<h3 id="Prefer-strconv-over-fmt"><a href="#Prefer-strconv-over-fmt" class="headerlink" title="Prefer strconv over fmt"></a>Prefer strconv over fmt</h3><p>When converting primitives to/from strings, <code>strconv</code> is faster than<br><code>fmt</code>.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := fmt.Sprint(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := strconv.Itoa(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkFmtSprint<span class="number">-4</span>    <span class="number">143</span> ns/op    <span class="number">2</span> allocs/op</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStrconv<span class="number">-4</span>    <span class="number">64.2</span> ns/op    <span class="number">1</span> allocs/op</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Avoid-string-to-byte-conversion"><a href="#Avoid-string-to-byte-conversion" class="headerlink" title="Avoid string-to-byte conversion"></a>Avoid string-to-byte conversion</h3><p>Do not create byte slices from a fixed string repeatedly. Instead, perform the<br>conversion once and capture the result.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello world"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"Hello world"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad<span class="number">-4</span>   <span class="number">50000000</span>   <span class="number">22.2</span> ns/op</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood<span class="number">-4</span>  <span class="number">500000000</span>   <span class="number">3.25</span> ns/op</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Prefer-Specifying-Container-Capacity"><a href="#Prefer-Specifying-Container-Capacity" class="headerlink" title="Prefer Specifying Container Capacity"></a>Prefer Specifying Container Capacity</h3><p>Specify container capacity where possible in order to allocate memory for the<br>container up front. This minimizes subsequent allocations (by copying and<br>resizing of the container) as elements are added.</p>
<h4 id="Specifying-Map-Capacity-Hints"><a href="#Specifying-Map-Capacity-Hints" class="headerlink" title="Specifying Map Capacity Hints"></a>Specifying Map Capacity Hints</h4><p>Where possible, provide capacity hints when initializing<br>maps with <code>make()</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, hint)</span><br></pre></td></tr></table></figure>
<p>Providing a capacity hint to <code>make()</code> tries to right-size the<br>map at initialization time, which reduces the need for growing<br>the map and allocations as elements are added to the map.</p>
<p>Note that, unlike slices, map capacity hints do not guarantee complete,<br>preemptive allocation, but are used to approximate the number of hashmap buckets<br>required. Consequently, allocations may still occur when adding elements to the<br>map, even up to the specified capacity.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo)</span><br><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo, <span class="built_in">len</span>(files))</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><code>m</code> is created without a size hint; there may be more<br>allocations at assignment time.<br><br></td><td><br><br><code>m</code> is created with a size hint; there may be fewer<br>allocations at assignment time.<br><br></td></tr><br></tbody></table>

<h4 id="Specifying-Slice-Capacity"><a href="#Specifying-Slice-Capacity" class="headerlink" title="Specifying Slice Capacity"></a>Specifying Slice Capacity</h4><p>Where possible, provide capacity hints when initializing slices with <code>make()</code>,<br>particularly when appending.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure>
<p>Unlike maps, slice capacity is not a hint: the compiler will allocate enough<br>memory for the capacity of the slice as provided to <code>make()</code>, which means that<br>subsequent <code>append()</code> operations will incur zero allocations (until the length<br>of the slice matches the capacity, after which any appends will require a resize<br>to hold additional elements).</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad<span class="number">-4</span>    <span class="number">100000000</span>    <span class="number">2.48</span>s</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood<span class="number">-4</span>   <span class="number">100000000</span>    <span class="number">0.21</span>s</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h2 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h2><h3 id="Be-Consistent"><a href="#Be-Consistent" class="headerlink" title="Be Consistent"></a>Be Consistent</h3><p>Some of the guidelines outlined in this document can be evaluated objectively;<br>others are situational, contextual, or subjective.</p>
<p>Above all else, <strong>be consistent</strong>.</p>
<p>Consistent code is easier to maintain, is easier to rationalize, requires less<br>cognitive overhead, and is easier to migrate or update as new conventions emerge<br>or classes of bugs are fixed.</p>
<p>Conversely, having multiple disparate or conflicting styles within a single<br>codebase causes maintenance overhead, uncertainty, and cognitive dissonance,<br>all of which can directly contribute to lower velocity, painful code reviews,<br>and bugs.</p>
<p>When applying these guidelines to a codebase, it is recommended that changes<br>are made at a package (or larger) level: application at a sub-package level<br>violates the above concern by introducing multiple styles into the same code.</p>
<h3 id="Group-Similar-Declarations"><a href="#Group-Similar-Declarations" class="headerlink" title="Group Similar Declarations"></a>Group Similar Declarations</h3><p>Go supports grouping similar declarations.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"a"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"b"</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"a"</span></span><br><span class="line">  <span class="string">"b"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>This also applies to constants, variables, and type declarations.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Area <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Volume <span class="keyword">float64</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  Area <span class="keyword">float64</span></span><br><span class="line">  Volume <span class="keyword">float64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Only group related declarations. Do not group declarations that are unrelated.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">  EnvVar = <span class="string">"MY_ENV"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EnvVar = <span class="string">"MY_ENV"</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Groups are not limited in where they can be used. For example, you can use them<br>inside of functions.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> red = color.New(<span class="number">0xff</span>0000)</span><br><span class="line">  <span class="keyword">var</span> green = color.New(<span class="number">0x00ff</span>00)</span><br><span class="line">  <span class="keyword">var</span> blue = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    red   = color.New(<span class="number">0xff</span>0000)</span><br><span class="line">    green = color.New(<span class="number">0x00ff</span>00)</span><br><span class="line">    blue  = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Import-Group-Ordering"><a href="#Import-Group-Ordering" class="headerlink" title="Import Group Ordering"></a>Import Group Ordering</h3><p>There should be two import groups:</p>
<ul>
<li>Standard library</li>
<li>Everything else</li>
</ul>
<p>This is the grouping applied by goimports by default.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Package-Names"><a href="#Package-Names" class="headerlink" title="Package Names"></a>Package Names</h3><p>When naming packages, choose a name that is:</p>
<ul>
<li>All lower-case. No capitals or underscores.</li>
<li>Does not need to be renamed using named imports at most call sites.</li>
<li>Short and succinct. Remember that the name is identified in full at every call<br>site.</li>
<li>Not plural. For example, <code>net/url</code>, not <code>net/urls</code>.</li>
<li>Not “common”, “util”, “shared”, or “lib”. These are bad, uninformative names.</li>
</ul>
<p>See also <a href="https://blog.golang.org/package-names" target="_blank" rel="noopener">Package Names</a> and <a href="https://rakyll.org/style-packages/" target="_blank" rel="noopener">Style guideline for Go packages</a>.</p>
<h3 id="Function-Names"><a href="#Function-Names" class="headerlink" title="Function Names"></a>Function Names</h3><p>We follow the Go community’s convention of using <a href="https://golang.org/doc/effective_go.html#mixed-caps" target="_blank" rel="noopener">MixedCaps for function<br>names</a>. An exception is made for test functions, which may contain underscores<br>for the purpose of grouping related test cases, e.g.,<br><code>TestMyFunction_WhatIsBeingTested</code>.</p>
<h3 id="Import-Aliasing"><a href="#Import-Aliasing" class="headerlink" title="Import Aliasing"></a>Import Aliasing</h3><p>Import aliasing must be used if the package name does not match the last<br>element of the import path.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">  client <span class="string">"example.com/client-go"</span></span><br><span class="line">  trace <span class="string">"example.com/trace/v2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>In all other scenarios, import aliases should be avoided unless there is a<br>direct conflict between imports.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"runtime/trace"</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Function-Grouping-and-Ordering"><a href="#Function-Grouping-and-Ordering" class="headerlink" title="Function Grouping and Ordering"></a>Function Grouping and Ordering</h3><ul>
<li>Functions should be sorted in rough call order.</li>
<li>Functions in a file should be grouped by receiver.</li>
</ul>
<p>Therefore, exported functions should appear first in a file, after<br><code>struct</code>, <code>const</code>, <code>var</code> definitions.</p>
<p>A <code>newXYZ()</code>/<code>NewXYZ()</code> may appear after the type is defined, but before the<br>rest of the methods on the receiver.</p>
<p>Since functions are grouped by receiver, plain utility functions should appear<br>towards the end of the file.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Reduce-Nesting"><a href="#Reduce-Nesting" class="headerlink" title="Reduce Nesting"></a>Reduce Nesting</h3><p>Code should reduce nesting where possible by handling error cases/special<br>conditions first and returning early or continuing the loop. Reduce the amount<br>of code that is nested multiple levels.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 == <span class="number">1</span> &#123;</span><br><span class="line">    v = process(v)</span><br><span class="line">    <span class="keyword">if</span> err := v.Call(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 != <span class="number">1</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v = process(v)</span><br><span class="line">  <span class="keyword">if</span> err := v.Call(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Unnecessary-Else"><a href="#Unnecessary-Else" class="headerlink" title="Unnecessary Else"></a>Unnecessary Else</h3><p>If a variable is set in both branches of an if, it can be replaced with a<br>single if.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Top-level-Variable-Declarations"><a href="#Top-level-Variable-Declarations" class="headerlink" title="Top-level Variable Declarations"></a>Top-level Variable Declarations</h3><p>At the top level, use the standard <code>var</code> keyword. Do not specify the type,<br>unless it is not the same type as the expression.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s <span class="keyword">string</span> = F()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s = F()</span><br><span class="line"><span class="comment">// Since F already states that it returns a string, we don't need to specify</span></span><br><span class="line"><span class="comment">// the type again.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Specify the type if the type of the expression does not match the desired type<br>exactly.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"error"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">myError</span></span> &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _e error = F()</span><br><span class="line"><span class="comment">// F returns an object of type myError but we want error.</span></span><br></pre></td></tr></table></figure>
<h3 id="Prefix-Unexported-Globals-with"><a href="#Prefix-Unexported-Globals-with" class="headerlink" title="Prefix Unexported Globals with _"></a>Prefix Unexported Globals with _</h3><p>Prefix unexported top-level <code>var</code>s and <code>const</code>s with <code>_</code> to make it clear when<br>they are used that they are global symbols.</p>
<p>Exception: Unexported error values, which should be prefixed with <code>err</code>.</p>
<p>Rationale: Top-level variables and constants have a package scope. Using a<br>generic name makes it easy to accidentally use the wrong value in a different<br>file.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  defaultPort = <span class="number">8080</span></span><br><span class="line">  defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">  defaultPort := <span class="number">9090</span></span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(<span class="string">"Default port"</span>, defaultPort)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will not see a compile error if the first line of</span></span><br><span class="line">  <span class="comment">// Bar() is deleted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  _defaultPort = <span class="number">8080</span></span><br><span class="line">  _defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Embedding-in-Structs"><a href="#Embedding-in-Structs" class="headerlink" title="Embedding in Structs"></a>Embedding in Structs</h3><p>Embedded types (such as mutexes) should be at the top of the field list of a<br>struct, and there must be an empty line separating embedded fields from regular<br>fields.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">  http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  http.Client</span><br><span class="line"></span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Embedding should provide tangible benefit, like adding or augmenting<br>functionality in a semantically-appropriate way. It should do this with zero<br>adverse user-facing effects (see also: <a href="#avoid-embedding-types-in-public-structs">Avoid Embedding Types in Public Structs</a>).</p>
<p>Embedding <strong>should not</strong>:</p>
<ul>
<li>Be purely cosmetic or convenience-oriented.</li>
<li>Make outer types more difficult to construct or use.</li>
<li>Affect outer types’ zero values. If the outer type has a useful zero value, it<br>should still have a useful zero value after embedding the inner type.</li>
<li>Expose unrelated functions or fields from the outer type as a side-effect of<br>embedding the inner type.</li>
<li>Expose unexported types.</li>
<li>Affect outer types’ copy semantics.</li>
<li>Change the outer type’s API or type semantics.</li>
<li>Embed a non-canonical form of the inner type.</li>
<li>Expose implementation details of the outer type.</li>
<li>Allow users to observe or control type internals.</li>
<li>Change the general behavior of inner functions through wrapping in a way that<br>would reasonably surprise users.</li>
</ul>
<p>Simply put, embed consciously and intentionally. A good litmus test is, “would<br>all of these exported inner methods/fields be added directly to the outer type”;<br>if the answer is “some” or “no”, don’t embed the inner type - use a field<br>instead.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Bad: A.Lock() and A.Unlock() are</span></span><br><span class="line">    <span class="comment">//      now available, provide no</span></span><br><span class="line">    <span class="comment">//      functional benefit, and allow</span></span><br><span class="line">    <span class="comment">//      users to control details about</span></span><br><span class="line">    <span class="comment">//      the internals of A.</span></span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> countingWriteCloser <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Good: Write() is provided at this</span></span><br><span class="line">    <span class="comment">//       outer layer for a specific</span></span><br><span class="line">    <span class="comment">//       purpose, and delegates work</span></span><br><span class="line">    <span class="comment">//       to the inner type's Write().</span></span><br><span class="line">    io.WriteCloser</span><br><span class="line"></span><br><span class="line">    count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *countingWriteCloser)</span> <span class="title">Write</span><span class="params">(bs []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    w.count += <span class="built_in">len</span>(bs)</span><br><span class="line">    <span class="keyword">return</span> w.WriteCloser.Write(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Bad: pointer changes zero value usefulness</span></span><br><span class="line">    io.ReadWriter</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b Book</span><br><span class="line">b.Read(...)  <span class="comment">// panic: nil pointer</span></span><br><span class="line">b.String()   <span class="comment">// panic: nil pointer</span></span><br><span class="line">b.Write(...) <span class="comment">// panic: nil pointer</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Good: has useful zero value</span></span><br><span class="line">    bytes.Buffer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b Book</span><br><span class="line">b.Read(...)  <span class="comment">// ok</span></span><br><span class="line">b.String()   <span class="comment">// ok</span></span><br><span class="line">b.Write(...) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    sync.WaitGroup</span><br><span class="line">    bytes.Buffer</span><br><span class="line">    url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    mtx sync.Mutex</span><br><span class="line">    wg  sync.WaitGroup</span><br><span class="line">    buf bytes.Buffer</span><br><span class="line">    url url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Local-Variable-Declarations"><a href="#Local-Variable-Declarations" class="headerlink" title="Local Variable Declarations"></a>Local Variable Declarations</h3><p>Short variable declarations (<code>:=</code>) should be used if a variable is being set to<br>some value explicitly.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"foo"</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"foo"</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>However, there are cases where the default value is clearer when the <code>var</code><br>keyword is used. <a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices" target="_blank" rel="noopener">Declaring Empty Slices</a>, for example.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  filtered := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered []<span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="nil-is-a-valid-slice"><a href="#nil-is-a-valid-slice" class="headerlink" title="nil is a valid slice"></a>nil is a valid slice</h3><p><code>nil</code> is a valid slice of length 0. This means that,</p>
<ul>
<li><p>You should not return a slice of length zero explicitly. Return <code>nil</code><br>instead.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>
</li>
<li><p>To check if a slice is empty, always use <code>len(s) == 0</code>. Do not check for<br><code>nil</code>.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>
</li>
<li><p>The zero value (a slice declared with <code>var</code>) is usable immediately without<br><code>make()</code>.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// or, nums := make([]int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

</li>
</ul>
<p>Remember that, while it is a valid slice, a nil slice is not equivalent to an<br>allocated slice of length 0 - one is nil and the other is not - and the two may<br>be treated differently in different situations (such as serialization).</p>
<h3 id="Reduce-Scope-of-Variables"><a href="#Reduce-Scope-of-Variables" class="headerlink" title="Reduce Scope of Variables"></a>Reduce Scope of Variables</h3><p>Where possible, reduce scope of variables. Do not reduce the scope if it<br>conflicts with <a href="#reduce-nesting">Reduce Nesting</a>.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := ioutil.WriteFile(name, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(name, data, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>If you need a result of a function call outside of the if, then you should not<br>try to reduce the scope.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> data, err := ioutil.ReadFile(name); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  err = cfg.Decode(data)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(cfg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cfg.Decode(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(cfg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Avoid-Naked-Parameters"><a href="#Avoid-Naked-Parameters" class="headerlink" title="Avoid Naked Parameters"></a>Avoid Naked Parameters</h3><p>Naked parameters in function calls can hurt readability. Add C-style comments<br>(<code>/* ... */</code>) for parameter names when their meaning is not obvious.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Better yet, replace naked <code>bool</code> types with custom types for more readable and<br>type-safe code. This allows more than just two states (true/false) for that<br>parameter in the future.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Region <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  UnknownRegion Region = <span class="literal">iota</span></span><br><span class="line">  Local</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusReady Status = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  StatusDone</span><br><span class="line">  <span class="comment">// Maybe we will have a StatusInProgress in the future.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="keyword">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Use-Raw-String-Literals-to-Avoid-Escaping"><a href="#Use-Raw-String-Literals-to-Avoid-Escaping" class="headerlink" title="Use Raw String Literals to Avoid Escaping"></a>Use Raw String Literals to Avoid Escaping</h3><p>Go supports <a href="https://golang.org/ref/spec#raw_string_lit" target="_blank" rel="noopener">raw string literals</a>,<br>which can span multiple lines and include quotes. Use these to avoid<br>hand-escaped strings which are much harder to read.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">"unknown name:\"test\""</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">`unknown error:"test"`</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Initializing-Structs"><a href="#Initializing-Structs" class="headerlink" title="Initializing Structs"></a>Initializing Structs</h3><h4 id="Use-Field-Names-to-Initialize-Structs"><a href="#Use-Field-Names-to-Initialize-Structs" class="headerlink" title="Use Field Names to Initialize Structs"></a>Use Field Names to Initialize Structs</h4><p>You should almost always specify field names when initializing structs. This is<br>now enforced by <a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener"><code>go vet</code></a>.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;<span class="string">"John"</span>, <span class="string">"Doe"</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: <span class="string">"John"</span>,</span><br><span class="line">    LastName: <span class="string">"Doe"</span>,</span><br><span class="line">    Admin: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Exception: Field names <em>may</em> be omitted in test tables when there are 3 or<br>fewer fields.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">"add"</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">"subtract"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Omit-Zero-Value-Fields-in-Structs"><a href="#Omit-Zero-Value-Fields-in-Structs" class="headerlink" title="Omit Zero Value Fields in Structs"></a>Omit Zero Value Fields in Structs</h4><p>When initializing structs with field names, omit fields that have zero values<br>unless they provide meaningful context. Otherwise, let Go set these to zero<br>values automatically.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: <span class="string">"John"</span>,</span><br><span class="line">  LastName: <span class="string">"Doe"</span>,</span><br><span class="line">  MiddleName: <span class="string">""</span>,</span><br><span class="line">  Admin: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: <span class="string">"John"</span>,</span><br><span class="line">  LastName: <span class="string">"Doe"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>This helps reduce noise for readers by omitting values that are default in<br>that context. Only meaningful values are specified.</p>
<p>Include zero values where field names provide meaningful context. For example,<br>test cases in <a href="#test-tables">Test Tables</a> can benefit from names of fields<br>even when they are zero-valued.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give <span class="keyword">string</span></span><br><span class="line">  want <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;give: <span class="string">"0"</span>, want: <span class="number">0</span>&#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Use-var-for-Zero-Value-Structs"><a href="#Use-var-for-Zero-Value-Structs" class="headerlink" title="Use var for Zero Value Structs"></a>Use <code>var</code> for Zero Value Structs</h4><p>When all the fields of a struct are omitted in a declaration, use the <code>var</code><br>form to declare the struct.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>This differentiates zero valued structs from those with non-zero fields<br>similar to the distinction created for <a href="#initializing-maps">map initialization</a>, and matches how<br>we prefer to <a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices" target="_blank" rel="noopener">declare empty slices</a>.</p>
<h4 id="Initializing-Struct-References"><a href="#Initializing-Struct-References" class="headerlink" title="Initializing Struct References"></a>Initializing Struct References</h4><p>Use <code>&amp;T{}</code> instead of <code>new(T)</code> when initializing struct references so that it<br>is consistent with the struct initialization.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inconsistent</span></span><br><span class="line">sptr := <span class="built_in">new</span>(T)</span><br><span class="line">sptr.Name = <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line">sptr := &amp;T&#123;Name: <span class="string">"bar"</span>&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Initializing-Maps"><a href="#Initializing-Maps" class="headerlink" title="Initializing Maps"></a>Initializing Maps</h3><p>Prefer <code>make(..)</code> for empty maps, and maps populated<br>programmatically. This makes map initialization visually<br>distinct from declaration, and it makes it easy to add size<br>hints later if available.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 is safe to read and write;</span></span><br><span class="line">  <span class="comment">// m2 will panic on writes.</span></span><br><span class="line">  m1 = <span class="keyword">map</span>[T1]T2&#123;&#125;</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 is safe to read and write;</span></span><br><span class="line">  <span class="comment">// m2 will panic on writes.</span></span><br><span class="line">  m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2)</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br>Declaration and initialization are visually similar.<br><br></td><td><br><br>Declaration and initialization are visually distinct.<br><br></td></tr><br></tbody></table>

<p>Where possible, provide capacity hints when initializing<br>maps with <code>make()</code>. See<br><a href="#specifying-map-capacity-hints">Specifying Map Capacity Hints</a><br>for more information.</p>
<p>On the other hand, if the map holds a fixed list of elements,<br>use map literals to initialize the map.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, <span class="number">3</span>)</span><br><span class="line">m[k1] = v1</span><br><span class="line">m[k2] = v2</span><br><span class="line">m[k3] = v3</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[T1]T2&#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">  k3: v3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>


<p>The basic rule of thumb is to use map literals when adding a fixed set of<br>elements at initialization time, otherwise use <code>make</code> (and specify a size hint<br>if available).</p>
<h3 id="Format-Strings-outside-Printf"><a href="#Format-Strings-outside-Printf" class="headerlink" title="Format Strings outside Printf"></a>Format Strings outside Printf</h3><p>If you declare format strings for <code>Printf</code>-style functions outside a string<br>literal, make them <code>const</code> values.</p>
<p>This helps <code>go vet</code> perform static analysis of the format string.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg := <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<h3 id="Naming-Printf-style-Functions"><a href="#Naming-Printf-style-Functions" class="headerlink" title="Naming Printf-style Functions"></a>Naming Printf-style Functions</h3><p>When you declare a <code>Printf</code>-style function, make sure that <code>go vet</code> can detect<br>it and check the format string.</p>
<p>This means that you should use predefined <code>Printf</code>-style function<br>names if possible. <code>go vet</code> will check these by default. See <a href="https://golang.org/cmd/vet/#hdr-Printf_family" target="_blank" rel="noopener">Printf family</a><br>for more information.</p>
<p>If using the predefined names is not an option, end the name you choose with<br>f: <code>Wrapf</code>, not <code>Wrap</code>. <code>go vet</code> can be asked to check specific <code>Printf</code>-style<br>names but they must end with f.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go vet -printfuncs=wrapf,statusf</span></span><br></pre></td></tr></table></figure>
<p>See also <a href="https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/" target="_blank" rel="noopener">go vet: Printf family check</a>.</p>
<h2 id="Patterns"><a href="#Patterns" class="headerlink" title="Patterns"></a>Patterns</h2><h3 id="Test-Tables"><a href="#Test-Tables" class="headerlink" title="Test Tables"></a>Test Tables</h3><p>Use table-driven tests with <a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">subtests</a> to avoid duplicating code when the core<br>test logic is repetitive.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">host, port, err := net.SplitHostPort(<span class="string">"192.0.2.0:8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"192.0.2.0:http"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"http"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">":8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">""</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"1:8"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"1"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8"</span>, port)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:8000"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:http"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"http"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">":8000"</span>,</span><br><span class="line">    wantHost: <span class="string">""</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"1:8"</span>,</span><br><span class="line">    wantHost: <span class="string">"1"</span>,</span><br><span class="line">    wantPort: <span class="string">"8"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    host, port, err := net.SplitHostPort(tt.give)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    assert.Equal(t, tt.wantHost, host)</span><br><span class="line">    assert.Equal(t, tt.wantPort, port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Test tables make it easier to add context to error messages, reduce duplicate<br>logic, and add new test cases.</p>
<p>We follow the convention that the slice of structs is referred to as <code>tests</code><br>and each test case <code>tt</code>. Further, we encourage explicating the input and output<br>values for each test case with <code>give</code> and <code>want</code> prefixes.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Functional-Options"><a href="#Functional-Options" class="headerlink" title="Functional Options"></a>Functional Options</h3><p>Functional options is a pattern in which you declare an opaque <code>Option</code> type<br>that records information in some internal struct. You accept a variadic number<br>of these options and act upon the full information recorded by the options on<br>the internal struct.</p>
<p>Use this pattern for optional arguments in constructors and other public APIs<br>that you foresee needing to expand, especially if you already have three or<br>more arguments on those functions.</p>
<table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  logger *zap.Logger</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br>The cache and logger parameters must always be provided, even if the user<br>wants to use the default.<br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.Open(addr, db.DefaultCache, zap.NewNop())</span><br><span class="line">db.Open(addr, db.DefaultCache, log)</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, zap.NewNop())</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, log)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br>Options are provided only if needed.<br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Open(addr)</span><br><span class="line">db.Open(addr, db.WithLogger(log))</span><br><span class="line">db.Open(addr, db.WithCache(<span class="literal">false</span>))</span><br><span class="line">db.Open(</span><br><span class="line">  addr,</span><br><span class="line">  db.WithCache(<span class="literal">false</span>),</span><br><span class="line">  db.WithLogger(log),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table>

<p>Our suggested way of implementing this pattern is with an <code>Option</code> interface<br>that holds an unexported method, recording options on an unexported <code>options</code><br>struct.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">  cache  <span class="keyword">bool</span></span><br><span class="line">  logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  apply(*options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cacheOption <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheOption)</span> <span class="title">apply</span><span class="params">(opts *options)</span></span> &#123;</span><br><span class="line">  opts.cache = <span class="keyword">bool</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> cacheOption(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggerOption <span class="keyword">struct</span> &#123;</span><br><span class="line">  Log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l loggerOption)</span> <span class="title">apply</span><span class="params">(opts *options)</span></span> &#123;</span><br><span class="line">  opts.logger = l.Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> loggerOption&#123;Log: log&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  options := options&#123;</span><br><span class="line">    cache:  defaultCache,</span><br><span class="line">    logger: zap.NewNop(),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">    o.apply(&amp;options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that there’s a method of implementing this pattern with closures but we<br>believe that the pattern above provides more flexibility for authors and is<br>easier to debug and test for users. In particular, it allows options to be<br>compared against each other in tests and mocks, versus closures where this is<br>impossible. Further, it lets options implement other interfaces, including<br><code>fmt.Stringer</code> which allows for user-readable string representations of the<br>options.</p>
<p>See also,</p>
<ul>
<li><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">Self-referential functions and the design of options</a></li>
<li><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">Functional options for friendly APIs</a></li>
</ul>
<!-- TODO: replace this with parameter structs and functional options, when to
use one vs other -->
<h2 id="Linting"><a href="#Linting" class="headerlink" title="Linting"></a>Linting</h2><p>More importantly than any “blessed” set of linters, lint consistently across a<br>codebase.</p>
<p>We recommend using the following linters at a minimum, because we feel that they<br>help to catch the most common issues and also establish a high bar for code<br>quality without being unnecessarily prescriptive:</p>
<ul>
<li><a href="https://github.com/kisielk/errcheck" target="_blank" rel="noopener">errcheck</a> to ensure that errors are handled</li>
<li><a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">goimports</a> to format code and manage imports</li>
<li><a href="https://github.com/golang/lint" target="_blank" rel="noopener">golint</a> to point out common style mistakes</li>
<li><a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener">govet</a> to analyze code for common mistakes</li>
<li><a href="https://staticcheck.io/" target="_blank" rel="noopener">staticcheck</a> to do various static analysis checks</li>
</ul>
<h3 id="Lint-Runners"><a href="#Lint-Runners" class="headerlink" title="Lint Runners"></a>Lint Runners</h3><p>We recommend <a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">golangci-lint</a> as the go-to lint runner for Go code, largely due<br>to its performance in larger codebases and ability to configure and use many<br>canonical linters at once. This repo has an example <a href="https://github.com/uber-go/guide/blob/master/.golangci.yml" target="_blank" rel="noopener">.golangci.yml</a> config file<br>with recommended linters and settings.</p>
<p>golangci-lint has <a href="https://golangci-lint.run/usage/linters/" target="_blank" rel="noopener">various linters</a> available for use. The above linters are<br>recommended as a base set, and we encourage teams to add any additional linters<br>that make sense for their projects.</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Uber-GO/">Uber, GO</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat20.png" title="微信"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2016 - 2021 Willie Lin</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>